<div id="skill-modal-container"></div>

<!-- Generated description functions from .script files -->
{% load static %}
<script src="{% static 'js/description-runtime.js' %}?v=8"></script>
<script src="{% static 'js/generated/game_data.js' %}?v=7"></script>
<script src="{% static 'js/generated/description_functions.js' %}?v=7"></script>
<script src="{% static 'js/hero-state.js' %}?v=7"></script>

<script>
// Auto-focus search bar when any modal opens
// Uses MutationObserver to handle all current and future modals
(function() {
    const modalContainer = document.getElementById('skill-modal-container');
    if (!modalContainer) return;

    const observer = new MutationObserver((mutations) => {
        for (const mutation of mutations) {
            if (mutation.addedNodes.length > 0) {
                const searchInput = modalContainer.querySelector('.skill-search');
                if (searchInput) {
                    setTimeout(() => searchInput.focus(), 50);
                }
                break;
            }
        }
    });

    observer.observe(modalContainer, { childList: true });
})();

// Client-side state for hero build
const heroBuild = {
    heroId: '',
    heroFaction: '',
    heroViewRadius: 6,  // Hero's view radius for item description calculations
    baseHeroLevel: 1,   // Starting hero level from DOM
    heroSpecialization: null,  // Raw specialization data with bonuses
    skills: [],  // Array of 8 slots: {skillId, level, subskills} or null
    startingSkillIds: [],
    startingSkillLevels: {},  // Map of skillId -> starting level, to track upgrades
    // Equipment state
    equipment: {
        slots: {
            'unique': null,      // { id, name, icon, level, maxLevel, ... }
            'head': null,
            'back': null,
            'armor': null,
            'weapon': null,      // left_hand
            'shield': null,      // right_hand
            'belt': null,
            'boots': null,
            'ring-1': null,
            'ring-2': null,
            'accessory-1': null, // item_slot
            'accessory-2': null,
            'accessory-3': null,
            'accessory-4': null
        },
        backpack: new Array(24).fill(null)  // 4x6 grid
    },
    // Army state
    army: Array(7).fill(null),  // Array of 7 slots: {unitId, count, unitData} or null
    factionUnits: null  // Cached faction units from API
};

/**
 * Calculate current hero level based on skill changes.
 * Hero level = base level + new skills acquired + skill upgrades
 */
function getHeroLevel() {
    let level = heroBuild.baseHeroLevel;

    for (const skill of heroBuild.skills) {
        if (!skill) continue;

        const startingLevel = heroBuild.startingSkillLevels[skill.skillId];

        if (startingLevel === undefined) {
            // New skill (not in starting skills) - +1 for acquiring at Basic
            level += 1;
            // Plus any upgrades from Basic (level 1)
            level += (skill.level - 1);
        } else {
            // Starting skill - count only the upgrades from starting level
            level += (skill.level - startingLevel);
        }
    }

    return level;
}

const SkillManager = {
    init() {
        // Get hero info from DOM
        const heroCard = document.querySelector('[data-hero-faction]');
        heroBuild.heroFaction = heroCard?.dataset.heroFaction || '';
        heroBuild.heroId = heroCard?.dataset.heroId || '';
        heroBuild.heroViewRadius = parseInt(heroCard?.dataset.heroViewRadius || '6', 10);
        heroBuild.baseHeroLevel = parseInt(heroCard?.dataset.heroLevel || '1', 10);
        heroBuild.heroSpecialization = heroCard?.dataset.heroSpec ? JSON.parse(heroCard.dataset.heroSpec) : null;

        // Initialize skills array with 8 slots
        heroBuild.skills = new Array(8).fill(null);
        heroBuild.startingSkillLevels = {};

        // Get starting skills from DOM
        const skillSlots = document.querySelectorAll('.skill-with-subs');
        skillSlots.forEach((slot, index) => {
            const skillMain = slot.querySelector('.skill-main');
            const skillId = skillMain?.dataset.skillId;
            const skillLevel = parseInt(skillMain?.dataset.skillLevel) || 1;

            if (skillId) {
                // Extract name from tooltip if present
                const tooltipName = skillMain.querySelector('.tooltip-title')?.textContent || skillId;
                const tooltipDescEl = skillMain.querySelector('.tooltip-text');

                // Extract description pipeline fields from data attributes
                const descTemplate = tooltipDescEl?.dataset.skillTemplate || '';
                const descArgs = tooltipDescEl?.dataset.skillArgs ? JSON.parse(tooltipDescEl.dataset.skillArgs) : [];
                const rawData = tooltipDescEl?.dataset.skillRaw ? JSON.parse(tooltipDescEl.dataset.skillRaw) : null;

                // Remove level prefix from name if it exists
                const name = tooltipName.replace(/^(Basic|Advanced|Expert)\s+/, '');

                heroBuild.skills[index] = {
                    skillId: skillId,
                    level: skillLevel,
                    subskills: [null, null],
                    subskillNames: [null, null],
                    subskillDescs: [null, null],
                    subskillRawData: [null, null],
                    name: name,
                    description: '', // Will be computed dynamically
                    description_template: descTemplate,
                    description_args: descArgs,
                    raw_data: rawData
                };
                heroBuild.startingSkillIds.push(skillId);
                heroBuild.startingSkillLevels[skillId] = skillLevel;  // Track starting level
            }
        });

        // Fetch full skill data and enrich starting skills with template/args/raw_data
        fetch(`/api/skills/available/?hero_slug=${heroBuild.heroId}`)
            .then(response => response.json())
            .then(data => {
                const skillsMap = {};
                data.skills.forEach(s => { skillsMap[s.id] = s; });

                // Enrich starting skills with full data for dynamic descriptions
                heroBuild.skills.forEach((skill, index) => {
                    if (skill && skillsMap[skill.skillId]) {
                        const fullData = skillsMap[skill.skillId];
                        skill.description_template = fullData.description_template || '';
                        skill.description_args = fullData.description_args || [];
                        skill.raw_data = fullData.raw_data || null;
                    }
                });

                // Re-render UI now that skills have full data
                this.updateUI();
            })
            .catch(err => console.warn('Could not enrich starting skills:', err));

        // Set up all click handlers (including subskill buttons for starting skills)
        this.updateUI();
    },

    setupClickHandlers() {
        const skillSlots = document.querySelectorAll('.skill-with-subs');
        skillSlots.forEach((slot, index) => {
            const skillMain = slot.querySelector('.skill-main');

            // Check if it's an empty slot
            if (heroBuild.skills[index] === null) {
                skillMain.style.cursor = 'pointer';
                skillMain.onclick = () => SkillSelectionModal.open(index);
            }
        });
    },

    addSkill(slotIndex, skillData) {
        heroBuild.skills[slotIndex] = {
            skillId: skillData.id,
            level: 1,
            subskills: [null, null],
            subskillNames: [null, null],
            subskillDescs: [null, null],
            subskillRawData: [null, null],
            name: skillData.name,
            icon: skillData.icon,
            description: skillData.description || '',
            description_template: skillData.description_template || '',
            description_args: skillData.description_args || [],
            raw_data: skillData.raw_data || null
        };
        this.updateUI();
        // Update all descriptions since skill bonuses may affect them
        EquipmentManager.updateAllDescriptions();
        // Update skill-granted spells
        if (typeof SpellBookManager !== 'undefined') {
            SpellBookManager.updateSkillGrantedSpells();
        }
    },

    getSelectedSkillIds() {
        return heroBuild.skills
            .filter(s => s !== null)
            .map(s => s.skillId);
    },

    levelUpSkill(slotIndex, subskillId, subskillName, subskillDesc, subskillRawData) {
        const skill = heroBuild.skills[slotIndex];
        if (!skill || skill.level >= 3) return;

        // Store subskill at the appropriate index (0 for Basic→Advanced, 1 for Advanced→Expert)
        const subskillIndex = skill.level - 1;
        skill.subskills[subskillIndex] = subskillId;
        skill.subskillNames[subskillIndex] = subskillName;
        skill.subskillDescs[subskillIndex] = subskillDesc || '';
        skill.subskillRawData[subskillIndex] = subskillRawData || null;

        // Increase level
        skill.level++;

        // Update UI and descriptions (skill level affects bonuses)
        this.updateUI();
        EquipmentManager.updateAllDescriptions();
        // Update skill-granted spells (higher levels may grant more spells)
        if (typeof SpellBookManager !== 'undefined') {
            SpellBookManager.updateSkillGrantedSpells();
        }
    },

    repickSubskill(slotIndex, subskillSlot, subskillId, subskillName, subskillDesc, subskillRawData) {
        const skill = heroBuild.skills[slotIndex];
        if (!skill) return;

        // Replace the subskill at the specified slot (no level change)
        skill.subskills[subskillSlot] = subskillId;
        skill.subskillNames[subskillSlot] = subskillName;
        skill.subskillDescs[subskillSlot] = subskillDesc || '';
        skill.subskillRawData[subskillSlot] = subskillRawData || null;

        // Update UI and descriptions (subskill bonuses may affect item descriptions)
        this.updateUI();
        EquipmentManager.updateAllDescriptions();
        // Update subskill-granted spells (changing subskill may add/remove spells)
        if (typeof SpellBookManager !== 'undefined') {
            SpellBookManager.updateSkillGrantedSpells();
        }
    },

    removeSkill(slotIndex) {
        const skill = heroBuild.skills[slotIndex];
        if (!skill) return;

        // Can't remove starting skills
        if (heroBuild.startingSkillIds.includes(skill.skillId)) {
            alert('Cannot remove starting skills');
            return;
        }

        // Reset slot
        heroBuild.skills[slotIndex] = null;
        this.updateUI();
        // Update descriptions since skill bonuses are removed
        EquipmentManager.updateAllDescriptions();
        // Update skill-granted spells (removed skill's spells should disappear)
        if (typeof SpellBookManager !== 'undefined') {
            SpellBookManager.updateSkillGrantedSpells();
        }
    },

    updateUI() {
        const skillSlots = document.querySelectorAll('.skill-with-subs');

        heroBuild.skills.forEach((skill, index) => {
            if (index >= skillSlots.length) return;

            const slot = skillSlots[index];
            const skillMain = slot.querySelector('.skill-main');
            const subskillBtns = slot.querySelectorAll('.subskill-btn');

            if (skill === null) {
                // Empty slot - show plus sign
                skillMain.innerHTML = '<span class="skill-add-text">+</span>';
                skillMain.style.cursor = 'pointer';
                skillMain.onclick = () => SkillSelectionModal.open(index);
                skillMain.oncontextmenu = null;
                skillMain.removeAttribute('data-skill-id');

                // Disable both subskill buttons
                subskillBtns.forEach(btn => {
                    btn.className = 'subskill-btn disabled';
                    btn.innerHTML = '';
                    btn.onclick = null;
                });
            } else {
                // Filled slot - show skill icon with tooltip
                const iconSuffix = skill.level > 1 ? `_${skill.level}` : '';
                const levelPrefix = skill.level === 1 ? 'Basic ' : skill.level === 2 ? 'Advanced ' : 'Expert ';

                skillMain.className = 'skill-main has-tooltip';
                skillMain.dataset.tooltipPlacement = 'bottom';
                skillMain.innerHTML = `
                    <img src="/media/gamedata/skills/${skill.skillId}${iconSuffix}.png" alt="${skill.name || skill.skillId}">
                    ${typeof AdvancedClassManager !== 'undefined' ? AdvancedClassManager.renderSkillIndicators(skill.skillId) : ''}
                    <div class="tooltip tooltip-skill">
                        <div class="tooltip-title">${levelPrefix}${skill.name || skill.skillId}</div>
                        ${(() => { const desc = EquipmentManager.formatSkillDescription(skill, skill.level); return desc ? `<div class="tooltip-text">${desc}</div>` : ''; })()}
                    </div>
                `;
                skillMain.dataset.skillId = skill.skillId;
                skillMain.dataset.skillLevel = skill.level;

                // Add right-click to remove (only for non-starting skills)
                if (!heroBuild.startingSkillIds.includes(skill.skillId)) {
                    skillMain.oncontextmenu = (e) => {
                        e.preventDefault();
                        if (confirm(`Remove ${skill.name || skill.skillId}?`)) {
                            SkillManager.removeSkill(index);
                        }
                    };
                } else {
                    skillMain.oncontextmenu = null;
                }

                // First subskill button
                if (skill.level === 1) {
                    // Can level up to Advanced
                    subskillBtns[0].className = 'subskill-btn';
                    subskillBtns[0].innerHTML = '<span class="add-text">+</span>';
                    subskillBtns[0].onclick = () => SubskillSelectionModal.open(index);
                } else if (!skill.subskills[0]) {
                    // Level 2+ but no first subskill yet (e.g., Lord Edgar starts at Advanced)
                    // Allow selecting first subskill without leveling up
                    subskillBtns[0].className = 'subskill-btn';
                    subskillBtns[0].innerHTML = '<span class="add-text">+</span>';
                    subskillBtns[0].onclick = () => SubskillSelectionModal.openForRepick(index, 0);
                } else {
                    // Show selected subskill with tooltip - clickable to repick
                    subskillBtns[0].className = 'subskill-btn filled has-tooltip';
                    subskillBtns[0].dataset.tooltipPlacement = 'bottom';
                    subskillBtns[0].innerHTML = `
                        <img src="/media/gamedata/skills/${skill.subskills[0]}_icon.png">
                        <div class="tooltip tooltip-skill">
                            <div class="tooltip-title">${skill.subskillNames[0] || skill.subskills[0]}</div>
                            ${skill.subskillDescs[0] ? `<div class="tooltip-text">${skill.subskillDescs[0]}</div>` : ''}
                        </div>
                    `;
                    subskillBtns[0].style.cursor = 'pointer';
                    subskillBtns[0].onclick = () => SubskillSelectionModal.openForRepick(index, 0);
                }

                // Second subskill button
                if (skill.level < 2) {
                    // Skill is Basic - second subskill not available
                    subskillBtns[1].className = 'subskill-btn disabled';
                    subskillBtns[1].innerHTML = '';
                    subskillBtns[1].onclick = null;
                } else if (skill.level === 2 && skill.subskills[0]) {
                    // Advanced with first subskill - can level up to Expert
                    subskillBtns[1].className = 'subskill-btn';
                    subskillBtns[1].innerHTML = '<span class="add-text">+</span>';
                    subskillBtns[1].onclick = () => SubskillSelectionModal.open(index);
                } else if (skill.level === 2 && !skill.subskills[0]) {
                    // Advanced but no first subskill - must pick first subskill first
                    subskillBtns[1].className = 'subskill-btn disabled';
                    subskillBtns[1].innerHTML = '';
                    subskillBtns[1].onclick = null;
                } else if (skill.level === 3 && !skill.subskills[1]) {
                    // Expert but no second subskill yet - allow selecting without level change
                    subskillBtns[1].className = 'subskill-btn';
                    subskillBtns[1].innerHTML = '<span class="add-text">+</span>';
                    subskillBtns[1].onclick = () => SubskillSelectionModal.openForRepick(index, 1);
                } else if (skill.subskills[1]) {
                    // Show selected subskill with tooltip - clickable to repick
                    subskillBtns[1].className = 'subskill-btn filled has-tooltip';
                    subskillBtns[1].dataset.tooltipPlacement = 'bottom';
                    subskillBtns[1].innerHTML = `
                        <img src="/media/gamedata/skills/${skill.subskills[1]}_icon.png">
                        <div class="tooltip tooltip-skill">
                            <div class="tooltip-title">${skill.subskillNames[1] || skill.subskills[1]}</div>
                            ${skill.subskillDescs[1] ? `<div class="tooltip-text">${skill.subskillDescs[1]}</div>` : ''}
                        </div>
                    `;
                    subskillBtns[1].style.cursor = 'pointer';
                    subskillBtns[1].onclick = () => SubskillSelectionModal.openForRepick(index, 1);
                }
            }
        });

        // Update advanced class progress tooltip
        if (typeof AdvancedClassManager !== 'undefined') {
            AdvancedClassManager.updateTooltip();
        }
    }
};

// Skill Selection Modal with API integration
const SkillSelectionModal = {
    allSkills: [],
    slotIndex: null,

    async open(slotIndex) {
        this.slotIndex = slotIndex;

        // Get faction from hero card data attribute
        const heroFaction = document.querySelector('[data-hero-faction]')?.dataset.heroFaction || '';
        const excludeIds = SkillManager.getSelectedSkillIds().join(',');

        // Fetch skills from API
        try {
            const response = await fetch(`/api/skills/available/?faction=${heroFaction}&exclude=${excludeIds}`);
            const data = await response.json();
            // Cache descriptions for search (computed once for performance)
            this.allSkills = (data.skills || []).map(skill => {
                // Compute description using transpiled pipeline if available
                const computedDesc = EquipmentManager.formatSkillDescription(skill, 1);
                return {
                    ...skill,
                    _computedDescription: computedDesc,
                    _cachedDescription: (computedDesc || skill.description || '').toLowerCase()
                };
            });
            this.render(this.allSkills);
        } catch (error) {
            console.error('Error fetching skills:', error);
            // Show error state
            const container = document.getElementById('skill-modal-container');
            container.innerHTML = `
                <div class="modal-overlay" onclick="SkillSelectionModal.close()">
                    <div class="skill-modal" onclick="event.stopPropagation()">
                        <div class="modal-header">
                            <h2>Select Skill</h2>
                            <p style="color: #ff6666;">Error loading skills. Please try again.</p>
                        </div>
                    </div>
                </div>
            `;
        }
    },

    render(skills) {
        const container = document.getElementById('skill-modal-container');
        container.innerHTML = `
            <div class="modal-overlay" onclick="SkillSelectionModal.close()">
                <div class="skill-modal" onclick="event.stopPropagation()">
                    <div class="modal-header">
                        <h2>Select Skill</h2>
                        <input type="text"
                               class="skill-search"
                               placeholder="Search skills..."
                               oninput="SkillSelectionModal.filter(this.value)">
                    </div>
                    <div class="skill-list" id="skill-list">
                        ${skills.map(s => this.renderSkillOption(s)).join('')}
                    </div>
                </div>
            </div>
        `;
    },

    renderSkillOption(skill) {
        // Use computed description (from transpiled pipeline) or fallback to pre-computed
        const displayDescription = skill._computedDescription || skill.description;
        return `
            <div class="skill-option" data-skill-id="${skill.id}"
                 onclick="SkillSelectionModal.select('${skill.id}')">
                <div class="skill-icon-wrapper">
                    <img src="/media/gamedata/skills/${skill.icon}.png" class="skill-icon" alt="${skill.name}">
                    ${typeof AdvancedClassManager !== 'undefined' ? AdvancedClassManager.renderSkillIndicators(skill.id) : ''}
                </div>
                <div class="skill-info">
                    <div class="skill-name">BASIC ${skill.name.toUpperCase()}</div>
                    <div class="skill-desc">${displayDescription}</div>
                </div>
                <div class="subskill-previews">
                    ${(skill.subskill_preview || []).map(sub =>
                        `<div class="subskill-preview-wrapper has-tooltip" data-tooltip-placement="bottom">
                            <img src="/media/gamedata/skills/${sub.icon}.png" class="subskill-preview-icon" alt="${sub.name}">
                            <div class="tooltip tooltip-skill">
                                <div class="tooltip-title">${sub.name}</div>
                                <div class="tooltip-text">${sub.description}</div>
                            </div>
                        </div>`
                    ).join('')}
                </div>
            </div>
        `;
    },

    filter(searchText) {
        const search = searchText.toLowerCase();
        const filtered = this.allSkills.filter(s =>
            s.name.toLowerCase().includes(search) ||
            (s._cachedDescription && s._cachedDescription.includes(search))
        );
        document.getElementById('skill-list').innerHTML =
            filtered.map(s => this.renderSkillOption(s)).join('');
    },

    select(skillId) {
        const skill = this.allSkills.find(s => s.id === skillId);
        if (skill) {
            SkillManager.addSkill(this.slotIndex, skill);
        }
        this.close();
    },

    close() {
        document.getElementById('skill-modal-container').innerHTML = '';
    }
};

const SubskillSelectionModal = {
    slotIndex: null,
    subskillSlot: null,  // 0 or 1, for repicking
    isRepick: false,
    currentSubskills: [],  // Store fetched subskills for raw_data access

    async open(slotIndex) {
        this.slotIndex = slotIndex;
        this.subskillSlot = null;
        this.isRepick = false;
        const skill = heroBuild.skills[slotIndex];
        if (!skill) return;

        const nextLevel = skill.level + 1;
        if (nextLevel > 3) return;  // Already at max level

        try {
            const response = await fetch(`/api/skills/${skill.skillId}/level/${nextLevel}/subskills/`);
            if (!response.ok) throw new Error('Failed to fetch subskills');
            const data = await response.json();
            this.render(data);
        } catch (error) {
            console.error('Error loading subskills:', error);
        }
    },

    async openForRepick(slotIndex, subskillSlot) {
        this.slotIndex = slotIndex;
        this.subskillSlot = subskillSlot;
        this.isRepick = true;
        const skill = heroBuild.skills[slotIndex];
        if (!skill) return;

        // subskillSlot 0 = level 2 subskills, subskillSlot 1 = level 3 subskills
        const level = subskillSlot + 2;

        try {
            const response = await fetch(`/api/skills/${skill.skillId}/level/${level}/subskills/`);
            if (!response.ok) throw new Error('Failed to fetch subskills');
            const data = await response.json();
            this.render(data);
        } catch (error) {
            console.error('Error loading subskills:', error);
        }
    },

    render(data) {
        // Store subskills for raw_data access in select()
        this.currentSubskills = data.subskills;

        // Get the skill from heroBuild to use its template/args for dynamic formatting
        const skill = heroBuild.skills[this.slotIndex];
        // Compute description dynamically at the new level
        const skillDesc = skill ?
            EquipmentManager.formatSkillDescription(skill, data.skill.level) :
            data.skill.description;

        const container = document.getElementById('skill-modal-container');
        container.innerHTML = `
            <div class="modal-overlay" onclick="SubskillSelectionModal.close()">
                <div class="subskill-modal" onclick="event.stopPropagation()">
                    <div class="upgraded-skill">
                        <img src="/media/gamedata/skills/${data.skill.icon}.png" class="skill-icon-large">
                        <div class="skill-info">
                            <div class="skill-name">${data.skill.name.toUpperCase()}</div>
                            <div class="skill-desc">${skillDesc}</div>
                        </div>
                    </div>
                    <div class="subskill-options">
                        ${data.subskills.map(sub => this.renderSubskillOption(sub)).join('')}
                    </div>
                </div>
            </div>
        `;
    },

    renderSubskillOption(subskill) {
        // Compute description dynamically using the Entity Description Pipeline
        const subskillDesc = EquipmentManager.formatSubskillDescription(subskill);

        return `
            <div class="subskill-option" onclick="SubskillSelectionModal.select('${subskill.id}')">
                <img src="/media/gamedata/skills/${subskill.icon}.png" class="subskill-icon">
                <div class="subskill-info">
                    <div class="subskill-name">${subskill.name}</div>
                    <div class="subskill-desc">${subskillDesc}</div>
                </div>
            </div>
        `;
    },

    select(subskillId) {
        // Find the full subskill data from stored subskills
        const subskill = this.currentSubskills.find(s => s.id === subskillId);
        const subskillName = subskill?.name || subskillId;
        const subskillDesc = subskill ? EquipmentManager.formatSubskillDescription(subskill) : '';
        const subskillRawData = subskill?.raw_data || null;

        if (this.isRepick) {
            SkillManager.repickSubskill(this.slotIndex, this.subskillSlot, subskillId, subskillName, subskillDesc, subskillRawData);
        } else {
            SkillManager.levelUpSkill(this.slotIndex, subskillId, subskillName, subskillDesc, subskillRawData);
        }
        this.close();
    },

    close() {
        document.getElementById('skill-modal-container').innerHTML = '';
    }
};

const ItemSelectionModal = {
    allItems: [],
    currentSlot: null,
    currentSlotType: null,
    showScrolls: false,  // Hide scrolls by default in accessory slot

    // Map UI slot types (from data-slot-type) to API slot types
    slotTypeMap: {
        'unique': 'unique',
        'head': 'head',
        'back': 'back',
        'armor': 'armor',
        'weapon': 'weapon',
        'shield': 'shield',
        'belt': 'belt',
        'boots': 'boots',
        'ring': 'ring',
        'accessory': 'accessory'
    },

    // Rarity colors
    rarityColors: {
        'common': '#ffffff',
        'uncommon': '#1eff00',
        'rare': '#0070dd',
        'epic': '#a335ee',
        'legendary': '#ff8000',
        'relic': '#e6cc80'
    },

    async open(slotId, slotType) {
        this.currentSlot = slotId;
        this.currentSlotType = slotType;

        // Map UI slot type to API slot type
        const apiSlotType = this.slotTypeMap[slotType] || slotType;

        // Fetch items from API
        try {
            const response = await fetch(`/api/items/available/?slot=${apiSlotType}`);
            if (!response.ok) throw new Error('Failed to fetch items');
            const data = await response.json();
            // Cache descriptions and set names for search (computed once for performance)
            this.allItems = (data.items || []).map(item => {
                const setData = item.item_set ? ItemSetManager.getSetForItem(item.id) : null;
                return {
                    ...item,
                    _cachedDescription: (EquipmentManager.formatItemDescription(item) || '').toLowerCase(),
                    _cachedSetName: setData ? setData.name.toLowerCase() : ''
                };
            });
            this.render();
        } catch (error) {
            console.error('Error fetching items:', error);
            // Show error state
            const container = document.getElementById('skill-modal-container');
            container.innerHTML = `
                <div class="modal-overlay" onclick="ItemSelectionModal.close()">
                    <div class="skill-modal" onclick="event.stopPropagation()">
                        <div class="modal-header">
                            <h2>Select Item</h2>
                            <p style="color: #ff6666;">Error loading items. Please try again.</p>
                        </div>
                    </div>
                </div>
            `;
        }
    },

    // Check if an item is a scroll
    isScroll(item) {
        return item.id && item.id.toLowerCase().includes('scroll');
    },

    // Rarity sort order (lower = higher priority)
    rarityOrder: {
        'legendary': 0,
        'epic': 1,
        'rare': 2,
        'uncommon': 3,
        'common': 4
    },

    // Get filtered items based on search and scroll toggle, sorted by rarity
    getFilteredItems(searchText = '') {
        const search = searchText.toLowerCase();
        const filtered = this.allItems.filter(item => {
            // Filter by scroll toggle (only for accessory slot)
            if (this.currentSlotType === 'accessory' && !this.showScrolls && this.isScroll(item)) {
                return false;
            }
            // Filter by search text (name, description, or set name)
            if (search) {
                return item.name.toLowerCase().includes(search) ||
                       (item._cachedDescription && item._cachedDescription.includes(search)) ||
                       (item._cachedSetName && item._cachedSetName.includes(search));
            }
            return true;
        });

        // Sort by rarity: Legendary > Epic > Rare > Uncommon > Common
        return filtered.sort((a, b) => {
            const orderA = this.rarityOrder[a.rarity] ?? 99;
            const orderB = this.rarityOrder[b.rarity] ?? 99;
            return orderA - orderB;
        });
    },

    toggleScrolls() {
        this.showScrolls = !this.showScrolls;
        // Re-render with current search text
        const searchInput = document.querySelector('.skill-search');
        const searchText = searchInput ? searchInput.value : '';
        this.updateItemList(searchText);
        // Update checkbox state
        const checkbox = document.getElementById('show-scrolls-toggle');
        if (checkbox) checkbox.checked = this.showScrolls;
    },

    updateItemList(searchText = '') {
        const filtered = this.getFilteredItems(searchText);
        document.getElementById('item-list').innerHTML =
            filtered.map(item => this.renderItemOption(item)).join('');
    },

    render() {
        const container = document.getElementById('skill-modal-container');
        const isAccessory = this.currentSlotType === 'accessory';
        const scrollToggleHtml = isAccessory ? `
            <label class="scroll-toggle">
                <input type="checkbox" id="show-scrolls-toggle"
                       ${this.showScrolls ? 'checked' : ''}
                       onchange="ItemSelectionModal.toggleScrolls()">
                Show scrolls
            </label>
        ` : '';

        container.innerHTML = `
            <div class="modal-overlay" onclick="ItemSelectionModal.close()">
                <div class="skill-modal" onclick="event.stopPropagation()">
                    <div class="modal-header">
                        <h2>Select Item - ${this.currentSlotType}</h2>
                        <div class="modal-controls">
                            <input type="text"
                                   class="skill-search"
                                   placeholder="Search items..."
                                   oninput="ItemSelectionModal.filter(this.value)">
                            ${scrollToggleHtml}
                        </div>
                    </div>
                    <div class="skill-list" id="item-list">
                        ${this.getFilteredItems().map(item => this.renderItemOption(item)).join('')}
                    </div>
                </div>
            </div>
        `;
    },

    renderItemOption(item) {
        const rarityColor = this.rarityColors[item.rarity] || '#ffffff';
        // Always calculate description dynamically using EquipmentManager
        const displayText = EquipmentManager.formatItemDescription(item) ||
                           (item.bonuses || []).join(', ') ||
                           'No description';

        // Check if item belongs to a set
        let setHTML = '';
        if (item.item_set) {
            const setData = ItemSetManager.getSetForItem(item.id);
            if (setData) {
                const equippedCount = ItemSetManager.getEquippedSetItemCount(item.item_set);
                const totalItems = setData.items.length;
                setHTML = `
                    <div class="item-set-badge" title="${setData.name}">
                        <span class="set-name">${setData.name}</span>
                        <span class="set-count">(${equippedCount}/${totalItems})</span>
                    </div>
                `;
            }
        }

        return `
            <div class="skill-option" data-item-id="${item.id}"
                 onclick="ItemSelectionModal.select('${item.id}')">
                <div class="skill-icon-wrapper">
                    <img src="/media/gamedata/items/${item.icon}.png" class="skill-icon" alt="${item.name}">
                </div>
                <div class="skill-info">
                    <div class="skill-name-row">
                        <span class="skill-name" style="color: ${rarityColor};">${item.name.toUpperCase()}</span>
                        ${setHTML}
                    </div>
                    <div class="skill-desc" style="color: ${rarityColor}; opacity: 0.7; font-size: 0.8rem; margin-bottom: 5px;">
                        ${item.rarity.charAt(0).toUpperCase() + item.rarity.slice(1)}
                    </div>
                    <div class="skill-desc">${displayText}</div>
                </div>
            </div>
        `;
    },

    filter(searchText) {
        this.updateItemList(searchText);
    },

    select(itemId) {
        const item = this.allItems.find(i => i.id === itemId);
        if (item) {
            // Use EquipmentManager to equip the item
            EquipmentManager.equipItem(this.currentSlot, item);
        }
        this.close();
    },

    close() {
        document.getElementById('skill-modal-container').innerHTML = '';
    }
};

const AdvancedClassManager = {
    advancedClasses: [],  // Cached from API
    skillIndicators: {},  // Cached skill -> class mapping
    baseClassName: '',     // Base class name like "Cleric"
    baseClassDescription: '', // Base class description
    baseClassIconUrl: '',  // Original class badge icon URL

    async init() {
        // Get hero faction and class_type from DOM
        const heroCard = document.querySelector('[data-hero-faction]');
        const heroFaction = heroCard?.dataset.heroFaction || '';
        const heroClassType = heroCard?.dataset.heroClassType || '';

        if (!heroFaction || !heroClassType) return;

        // Fetch advanced classes (includes base class info)
        try {
            const response = await fetch(`/api/advanced-classes/?faction=${heroFaction}&class_type=${heroClassType}`);
            const data = await response.json();
            this.advancedClasses = data.advanced_classes || [];
            this.baseClassName = data.base_class_name || heroClassType;
            this.baseClassDescription = data.base_class_description || '';
            this.baseClassIconUrl = data.base_class_icon_url || '';
        } catch (e) {
            console.error('Error fetching advanced classes:', e);
        }

        // Fetch skill indicators
        try {
            const indicatorResponse = await fetch(`/api/advanced-classes/skill-indicators/?faction=${heroFaction}&class_type=${heroClassType}`);
            const indicatorData = await indicatorResponse.json();
            this.skillIndicators = indicatorData.skill_indicators || {};
        } catch (e) {
            console.error('Error fetching skill indicators:', e);
        }

        // Setup tooltip
        this.setupClassBadgeTooltip();

        // Refresh skill UI to add indicators to starting skills
        SkillManager.updateUI();
    },

    getSkillIndicators(skillId) {
        return this.skillIndicators[skillId] || [];
    },

    renderSkillIndicators(skillId) {
        const indicators = this.getSkillIndicators(skillId);
        if (indicators.length === 0) return '';

        return `<div class="skill-indicators">
            ${indicators.map(ind => `<img src="${ind.icon_url}" class="skill-indicator-icon" alt="${ind.class_id}">`).join('')}
        </div>`;
    },

    setupClassBadgeTooltip() {
        const wrapper = document.querySelector('.class-badge-wrapper');
        if (!wrapper) return;

        // Create tooltip content
        this.updateTooltip();
    },

    updateTooltip() {
        const wrapper = document.querySelector('.class-badge-wrapper');
        if (!wrapper) return;

        // Remove existing tooltip
        const existing = wrapper.querySelector('.tooltip');
        if (existing) existing.remove();

        // Build tooltip HTML
        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip tooltip-class';
        tooltip.innerHTML = this.renderTooltipContent();
        wrapper.appendChild(tooltip);

        // Also update the class badge icon if needed
        this.updateClassBadge();
    },

    renderTooltipContent() {
        // Get specialization data from DOM
        const wrapper = document.querySelector('.class-badge-wrapper');
        const specName = wrapper?.dataset.specName || '';
        const specTemplate = wrapper?.dataset.specTemplate || '';
        const specArgs = JSON.parse(wrapper?.dataset.specArgs || '[]');
        const specRaw = JSON.parse(wrapper?.dataset.specRaw || '{}');

        // Format specialization description using the entity description pipeline
        // Pass the raw specialization data as currentSpecialization context
        let specDesc = specTemplate;
        if (specArgs.length > 0 && typeof DescriptionRuntime !== 'undefined') {
            const ctx = { currentSpecialization: specRaw };
            specDesc = DescriptionRuntime.formatDescription(specTemplate, specArgs, ctx);
        }

        let html = `
            <div class="tooltip-header">
                <div class="tooltip-title tooltip-title--gold">${specName}</div>
                <div class="tooltip-text">${specDesc}</div>
            </div>
        `;

        // Advanced classes
        if (this.advancedClasses.length > 0) {
            html += '<div class="tooltip-divider"></div>';

            for (const advClass of this.advancedClasses) {
                const progress = this.calculateProgress(advClass);
                // Format advanced class description using the entity description pipeline
                let advDesc = advClass.description;
                if (advClass.description_args?.length > 0 && typeof DescriptionRuntime !== 'undefined') {
                    advDesc = DescriptionRuntime.formatDescription(advClass.description_template || advClass.description, advClass.description_args, {});
                }
                html += `
                    <div class="advanced-class-section">
                        <div class="advanced-class-header">
                            <img src="${advClass.icon_url}" class="advanced-class-icon" alt="${advClass.name}">
                            <span class="advanced-class-name">${advClass.name}</span>
                            <span class="advanced-class-progress">${progress}/5</span>
                        </div>
                        <div class="advanced-class-progress-bar">
                            <div class="progress-fill" style="width: ${progress * 20}%"></div>
                        </div>
                        <div class="advanced-class-desc">${advDesc}</div>
                    </div>
                `;
            }
        }

        return html;
    },

    calculateProgress(advClass) {
        // For now return 0, will be implemented in Slice 4
        let count = 0;
        for (const condition of advClass.activation_conditions) {
            const skillId = condition.skillSid;
            const requiredLevel = condition.skillLevel;

            // Check if hero has this skill at required level
            const heroSkill = heroBuild.skills.find(s => s && s.skillId === skillId);
            if (heroSkill && heroSkill.level >= requiredLevel) {
                count++;
            }
        }
        return count;
    },

    checkEligibility() {
        // Find first advanced class with 5/5 progress
        for (const advClass of this.advancedClasses) {
            if (this.calculateProgress(advClass) >= 5) {
                return advClass;
            }
        }
        return null;
    },

    updateClassBadge() {
        const classBadge = document.querySelector('.class-badge');
        if (!classBadge) return;

        const achievedClass = this.checkEligibility();

        if (achievedClass) {
            // Update badge to advanced class icon
            classBadge.src = achievedClass.icon_url;
        } else {
            // Revert to base class icon
            classBadge.src = this.baseClassIconUrl;
        }
    }
};

// Equipment Manager
const EquipmentManager = {
    /**
     * Calculate bonuses for an item at a specific level
     * @param {Array} bonuses_raw - Raw bonus data with base, increment, levelStep
     * @param {number} level - Current upgrade level (0-based)
     * @returns {Array} Array of formatted bonus strings
     */
    // Friendly names for boolean stats
    BOOLEAN_STAT_NAMES: {
        'enableSquadReactionType': 'Shows Unit Initiative',
        'enableSquadCounts': 'Shows Unit Stack Counts',
        'enableEnemyHeroInfo': 'Shows Enemy Hero Info',
        'enableEnemyCityInfo': 'Shows Enemy City Info',
        'enableBansEvasion': 'Can Evade Bans',
        'enableBansEvasionBattle': 'Can Evade Bans in Battle',
        'enableSaveHeroByKill': 'Hero Survives Defeat',
        'enableSavePartyByEscape': 'Party Can Escape',
    },

    // Friendly names for complex stats
    STAT_DISPLAY_NAMES: {
        'finalHealingBonusPercent': 'Healing',
        'finalAbilityDamageBonusPercent': 'Ability Damage',
        'finalSummonBonusPercent': 'Summoning',
        'diplomacyEfficiencyPerBonus': 'Diplomacy',
        'landscapePenaltyPerBonus': 'Terrain Penalty',
        'flyMotionPerBonus': 'Flying Speed',
        'hp': 'HP',
        'offence': 'Offence',
        'defence': 'Defence',
    },

    // Convert camelCase to Title Case
    _camelToTitle(text) {
        const spaced = text.replace(/([A-Z])/g, ' $1');
        return spaced.trim().split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()).join(' ');
    },

    // Calculate bonus value with upgrade scaling
    _calculateBonusValue(baseValue, upgrade, level) {
        if (upgrade && level > 0) {
            const increment = upgrade.increment || 0;
            const levelStep = upgrade.levelStep || 1;
            if (levelStep > 0) {
                return baseValue + (increment * Math.floor(level / levelStep));
            }
        }
        return baseValue;
    },

    calculateBonusesForLevel(bonuses_raw, level) {
        if (!bonuses_raw || bonuses_raw.length === 0) {
            return ['No bonuses'];
        }

        const results = [];
        for (const bonus of bonuses_raw) {
            // If bonus is already a formatted string, use it as-is
            if (typeof bonus === 'string') {
                results.push(bonus);
                continue;
            }

            const bonusType = bonus.type;
            const parameters = bonus.parameters || [];
            const upgrade = bonus.upgrade || {};

            // Check activation level (level is 0-based, activationLevel is 1-based)
            const activationLevel = bonus.activationLevel || 1;
            if ((level + 1) < activationLevel) continue;

            if (bonusType === 'heroStat') {
                if (parameters.length < 2) continue;

                const statName = parameters[0];

                // Special handling for magicSchoolSet: [statName, school, "0", value]
                if (statName === 'magicSchoolSet' && parameters.length >= 4) {
                    const school = parameters[1].charAt(0).toUpperCase() + parameters[1].slice(1);
                    const baseValue = parseFloat(parameters[3]) || 1;
                    const value = Math.round(this._calculateBonusValue(baseValue, upgrade, level));
                    const sign = value >= 0 ? '+' : '';
                    results.push(`${sign}${value} ${school} Magic`);
                    continue;
                }

                const baseValueStr = parameters[1];

                // Handle boolean stats
                if (baseValueStr === 'true' || baseValueStr === 'false' || baseValueStr === true || baseValueStr === false) {
                    if (this.BOOLEAN_STAT_NAMES[statName]) {
                        results.push(this.BOOLEAN_STAT_NAMES[statName]);
                    } else {
                        const displayName = this._camelToTitle(statName.replace('enable', ''));
                        results.push(`Enables ${displayName}`);
                    }
                    continue;
                }

                // Handle numeric stats
                const baseValue = parseFloat(baseValueStr) || 0;
                const value = this._calculateBonusValue(baseValue, upgrade, level);
                const displayName = this.STAT_DISPLAY_NAMES[statName] || this._camelToTitle(statName);

                // Detect percentage stats (includes "Percent", "PerBonus", etc.)
                const isPercent = statName.toLowerCase().includes('percent') || statName.toLowerCase().includes('perbonus');
                const intValue = isPercent && Math.abs(value) < 1 ? Math.round(value * 100) : Math.round(value);
                const sign = intValue >= 0 ? '+' : '';

                if (isPercent) {
                    results.push(`${sign}${intValue}% ${displayName}`);
                } else {
                    results.push(`${sign}${intValue} ${displayName}`);
                }
            } else if (bonusType === 'unitStat') {
                if (parameters.length < 2) continue;
                const statName = parameters[0];
                const baseValue = parseFloat(parameters[1]) || 0;
                const value = this._calculateBonusValue(baseValue, upgrade, level);
                const displayName = this.STAT_DISPLAY_NAMES[statName] || this._camelToTitle(statName);

                const allegiance = bonus.receiverAllegiance || 'ally';
                const prefix = allegiance === 'enemy' ? 'Enemy units: ' : 'Units: ';

                // Detect percentage stats (includes "Percent", "PerBonus", etc.)
                const isPercent = statName.toLowerCase().includes('percent') || statName.toLowerCase().includes('perbonus');
                const intValue = isPercent && Math.abs(value) < 1 ? Math.round(value * 100) : Math.round(value);
                const sign = intValue >= 0 ? '+' : '';

                if (isPercent) {
                    results.push(`${prefix}${sign}${intValue}% ${displayName}`);
                } else {
                    results.push(`${prefix}${sign}${intValue} ${displayName}`);
                }
            } else if (bonusType === 'sideRes') {
                if (parameters.length < 2) continue;
                const resource = parameters[0].charAt(0).toUpperCase() + parameters[0].slice(1);
                const baseValue = parseFloat(parameters[1]) || 0;
                const value = Math.round(this._calculateBonusValue(baseValue, upgrade, level));
                results.push(`+${value} ${resource}/day`);
            } else if (bonusType === 'heroMagicAdditionMass') {
                if (parameters.length >= 3) {
                    const tier = parameters[2];
                    if (tier === 'any' || tier === null) {
                        results.push('Unlocks all spells');
                    } else {
                        results.push(`Unlocks all Tier ${tier} spells`);
                    }
                }
            } else if (bonusType === 'heroMagicAddition') {
                results.push('Grants spell');
            } else if (bonusType === 'battleSubskillBonus') {
                results.push('Grants battle skill');
            } else if (bonusType === 'unitBoolStat') {
                if (parameters.length >= 1) {
                    const statName = this._camelToTitle(parameters[0]);
                    results.push(`Units: ${statName}`);
                }
            } else if (bonusType === 'magicSchoolSet') {
                if (parameters.length >= 2) {
                    const school = parameters[0].charAt(0).toUpperCase() + parameters[0].slice(1);
                    const baseValue = parseInt(parameters[1]) || 1;
                    const value = Math.round(this._calculateBonusValue(baseValue, upgrade, level));
                    const sign = value >= 0 ? '+' : '';
                    results.push(`${sign}${value} ${school} Magic`);
                }
            } else if (bonusType === 'heroAbility') {
                if (parameters.length >= 1) {
                    const abilityName = this._camelToTitle(parameters[0]);
                    results.push(`Grants: ${abilityName}`);
                }
            }
        }

        return results.length > 0 ? results : ['No bonuses'];
    },

    /**
     * Calculate dust cost for upgrading to a specific level
     * @param {Object} itemData - Item data with cost_base and cost_per_level
     * @param {number} level - Target upgrade level (1-based, where 1 = base item)
     * @returns {number} Dust cost
     */
    calculateDustCost(itemData, level) {
        if (!itemData || level <= 1) {
            return 0;
        }

        const costBase = itemData.cost_base || 0;
        const costPerLevel = itemData.cost_per_level || 0;

        return costBase + costPerLevel * (level - 1);
    },

    /**
     * Get total dust cost for all equipped items
     * @returns {number} Total dust cost
     */
    getTotalDustCost() {
        let total = 0;
        for (const itemData of Object.values(heroBuild.equipment.slots)) {
            if (itemData) {
                total += this.calculateDustCost(itemData, itemData.level);
            }
        }
        return total;
    },

    /**
     * Update the dust cost display element
     */
    updateDustDisplay() {
        const displayElement = document.getElementById('total-equipment-dust');
        if (displayElement) {
            const totalDust = this.getTotalDustCost();
            const dustValue = displayElement.querySelector('.dust-value');
            if (dustValue) {
                dustValue.textContent = totalDust;
            }
        }
    },

    /**
     * Get effective hero stats including base stats and all equipment bonuses
     * @returns {Object} Hero stats object e.g., {viewRadius: 8, offence: 5, ...}
     */
    getEffectiveHeroStats() {
        // Start with base hero stats
        const stats = {
            viewRadius: heroBuild.heroViewRadius,
            offence: parseInt(document.querySelector('[data-stat="offence"] .stat-value')?.textContent || '0'),
            defence: parseInt(document.querySelector('[data-stat="defence"] .stat-value')?.textContent || '0'),
            spellPower: parseInt(document.querySelector('[data-stat="spell-power"] .stat-value')?.textContent || '0'),
            intelligence: parseInt(document.querySelector('[data-stat="intelligence"] .stat-value')?.textContent || '0'),
            luck: parseInt(document.querySelector('[data-stat="luck"] .stat-value')?.textContent || '0'),
            moral: parseInt(document.querySelector('[data-stat="moral"] .stat-value')?.textContent || '0'),
        };

        // Add bonuses from all equipped items
        for (const itemData of Object.values(heroBuild.equipment.slots)) {
            const bonuses = itemData?.raw_data?.bonuses;
            if (!bonuses) continue;
            const level = itemData.level || 1;

            for (const bonus of bonuses) {
                if (bonus.type !== 'heroStat') continue;
                const params = bonus.parameters || [];
                if (params.length < 2) continue;

                const statName = params[0];
                const baseValue = parseFloat(params[1]);
                if (isNaN(baseValue)) continue;

                const upgrade = bonus.upgrade || {};
                const value = this._calculateBonusValue(baseValue, upgrade, level - 1);

                // Map game stat names to our stat object keys
                const statMap = {
                    'viewRadius': 'viewRadius',
                    'offence': 'offence',
                    'defence': 'defence',
                    'spellPower': 'spellPower',
                    'intelligence': 'intelligence',
                    'luck': 'luck',
                    'moral': 'moral',
                };
                const key = statMap[statName];
                if (key) {
                    stats[key] = (stats[key] || 0) + value;
                }
            }
        }

        // Add bonuses from equipped skills
        for (const skillData of heroBuild.skills) {
            if (!skillData || !skillData.raw_data) continue;
            const level = skillData.level || 1;
            const levelData = skillData.raw_data.parametersPerLevel?.[level - 1];
            if (!levelData?.bonuses) continue;

            for (const bonus of levelData.bonuses) {
                if (bonus.type !== 'heroStat') continue;
                const params = bonus.parameters || [];
                if (params.length < 2) continue;

                const statName = params[0];
                const value = parseFloat(params[1]);
                if (isNaN(value)) continue;

                // Map game stat names to our stat object keys
                const statMap = {
                    'viewRadius': 'viewRadius',
                    'offence': 'offence',
                    'defence': 'defence',
                    'spellPower': 'spellPower',
                    'intelligence': 'intelligence',
                    'luck': 'luck',
                    'moral': 'moral',
                };
                const key = statMap[statName];
                if (key) {
                    stats[key] = (stats[key] || 0) + value;
                }
            }
        }

        // Add bonuses from subskills
        for (const skillData of heroBuild.skills) {
            if (!skillData) continue;

            for (let i = 0; i < 2; i++) {
                const subskillRawData = skillData.subskillRawData?.[i];
                if (!subskillRawData?.bonuses) continue;

                for (const bonus of subskillRawData.bonuses) {
                    if (bonus.type !== 'heroStat') continue;
                    const params = bonus.parameters || [];
                    if (params.length < 2) continue;

                    const statName = params[0];
                    const value = parseFloat(params[1]);
                    if (isNaN(value)) continue;

                    // Map game stat names to our stat object keys
                    const statMap = {
                        'viewRadius': 'viewRadius',
                        'offence': 'offence',
                        'defence': 'defence',
                        'spellPower': 'spellPower',
                        'intelligence': 'intelligence',
                        'luck': 'luck',
                        'moral': 'moral',
                    };
                    const key = statMap[statName];
                    if (key) {
                        stats[key] = (stats[key] || 0) + value;
                    }
                }
            }
        }

        // Add bonuses from hero specialization
        const spec = heroBuild.heroSpecialization;
        if (spec?.bonuses) {
            const heroLevel = getHeroLevel();
            for (const bonus of spec.bonuses) {
                // Skip bonuses that require a higher activation level
                if (bonus.activationLevel && bonus.activationLevel > heroLevel) continue;

                if (bonus.type !== 'heroStat') continue;
                const params = bonus.parameters || [];
                if (params.length < 2) continue;

                const statName = params[0];
                const baseValue = parseFloat(params[1]);
                if (isNaN(baseValue)) continue;

                // Calculate level-based upgrades (triggers at 5, 10, 15, etc.)
                let value = baseValue;
                const upgrade = bonus.upgrade;
                if (upgrade && upgrade.increment && upgrade.levelStep) {
                    const upgradeCount = Math.floor(heroLevel / upgrade.levelStep);
                    value += upgrade.increment * upgradeCount;
                }

                // Map game stat names to our stat object keys
                const statMap = {
                    'viewRadius': 'viewRadius',
                    'offence': 'offence',
                    'defence': 'defence',
                    'spellPower': 'spellPower',
                    'intelligence': 'intelligence',
                    'luck': 'luck',
                    'moral': 'moral',
                    'morale': 'moral',
                };
                const key = statMap[statName];
                if (key) {
                    stats[key] = (stats[key] || 0) + value;
                }
            }
        }

        // Add bonuses from unlocked advanced class (subclass)
        if (typeof AdvancedClassManager !== 'undefined') {
            const unlockedClass = AdvancedClassManager.checkEligibility();
            if (unlockedClass?.bonuses) {
                for (const bonus of unlockedClass.bonuses) {
                    if (bonus.type !== 'heroStat') continue;
                    const params = bonus.parameters || [];
                    if (params.length < 2) continue;

                    const statName = params[0];
                    const value = parseFloat(params[1]);
                    if (isNaN(value)) continue;

                    // Map game stat names to our stat object keys
                    // Note: percentage stats like 'offencePer' multiply base stat
                    const statMap = {
                        'viewRadius': 'viewRadius',
                        'offence': 'offence',
                        'defence': 'defence',
                        'spellPower': 'spellPower',
                        'intelligence': 'intelligence',
                        'luck': 'luck',
                        'moral': 'moral',
                        'morale': 'moral',
                    };

                    // Handle percentage bonuses (e.g., offencePer, defencePer)
                    if (statName.endsWith('Per')) {
                        const baseStat = statName.slice(0, -3);
                        const key = statMap[baseStat];
                        if (key && stats[key]) {
                            stats[key] = stats[key] * (1 + value);
                        }
                    } else {
                        const key = statMap[statName];
                        if (key) {
                            stats[key] = (stats[key] || 0) + value;
                        }
                    }
                }
            }
        }

        // Add bonuses from active item sets
        if (typeof ItemSetManager !== 'undefined' && ItemSetManager.itemSets.length > 0) {
            const setStatBonuses = ItemSetManager.getActiveSetStatBonuses();
            const statMap = {
                'viewRadius': 'viewRadius',
                'offence': 'offence',
                'defence': 'defence',
                'spellPower': 'spellPower',
                'intelligence': 'intelligence',
                'luck': 'luck',
                'moral': 'moral',
                'morale': 'moral',
            };

            for (const [statName, value] of Object.entries(setStatBonuses)) {
                const key = statMap[statName];
                if (key) {
                    stats[key] = (stats[key] || 0) + value;
                }
            }
        }

        return stats;
    },

    /**
     * Format an item's description using current effective hero stats
     * @param {Object} itemData - Item data with description_template and description_args/description_values
     * @param {number} level - Current upgrade level (1-based)
     * @returns {string} Formatted description
     */
    formatItemDescription(itemData, level = null) {
        if (!itemData.description_template) {
            return itemData.description || '';
        }

        level = level || itemData.level || 1;

        // Try using transpiled functions first (new system)
        if (itemData.description_args && itemData.description_args.length > 0 &&
            typeof DescriptionRuntime !== 'undefined' && typeof DescriptionFunctions !== 'undefined') {
            try {
                const effectiveStats = this.getEffectiveHeroStats();

                // Create context for the transpiled functions
                const ctx = {
                    currentItem: {
                        id: itemData.id,
                        level: level,
                        config: itemData.raw_data || { bonuses: [] }
                    },
                    currentHero: {
                        heroStat: effectiveStats
                    }
                };

                // Use DescriptionRuntime to format
                let result = DescriptionRuntime.formatDescription(
                    itemData.description_template,
                    itemData.description_args,
                    ctx
                );

                // Append upgrade description only if it adds new functionality (no computed args)
                // If upgrade has computed args, those values are already reflected in main description
                if (level > 1 && itemData.upgrade_description_template &&
                    (!itemData.upgrade_description_args || itemData.upgrade_description_args.length === 0)) {
                    result += ' ' + this.formatUpgradeDescription(itemData);
                }

                return result;
            } catch (e) {
                console.warn('[EquipmentManager] Transpiled function error, falling back:', e);
            }
        }

        // Fallback to legacy system using description_values
        if (!itemData.description_values || itemData.description_values.length === 0) {
            return itemData.description || itemData.description_template || '';
        }

        const effectiveStats = this.getEffectiveHeroStats();
        const resolvedValues = [];

        for (const valueInfo of itemData.description_values) {
            if (valueInfo.type === 'static') {
                resolvedValues.push(valueInfo.value);
            } else if (valueInfo.type === 'item_param') {
                const base = valueInfo.base || 0;
                const increment = valueInfo.increment || 0;
                const levelStep = valueInfo.levelStep || 1;
                let value = base;
                if (level > 1 && increment && levelStep > 0) {
                    value = base + increment * Math.floor((level - 1) / levelStep);
                }
                if (valueInfo.isPercent && Math.abs(value) < 1) {
                    value = value * 100;
                }
                resolvedValues.push(String(Math.floor(value)));
            } else if (valueInfo.type === 'hero_stat_multiplier') {
                const stat = valueInfo.stat;
                const multiplier = valueInfo.multiplier || 1;
                const statValue = effectiveStats[stat] || 6; // Default viewRadius = 6
                resolvedValues.push(String(Math.floor(statValue * multiplier)));
            } else {
                resolvedValues.push('?');
            }
        }

        // Replace {0}, {1}, etc. in template
        let result = itemData.description_template;
        for (let i = 0; i < resolvedValues.length; i++) {
            result = result.replace(`{${i}}`, resolvedValues[i]);
        }

        // Append upgrade description only if it adds new functionality (no computed args)
        // If upgrade has computed args, those values are already reflected in main description
        if (level > 1 && itemData.upgrade_description_template &&
            (!itemData.upgrade_description_args || itemData.upgrade_description_args.length === 0)) {
            result += ' ' + this.formatUpgradeDescription(itemData);
        }

        return result;
    },

    /**
     * Format an item's upgrade description.
     * @param {Object} itemData - Item data with upgrade_description_template and upgrade_description_args
     * @returns {string} Formatted upgrade description
     */
    formatUpgradeDescription(itemData) {
        if (!itemData.upgrade_description_template) {
            return itemData.upgrade_description || '';
        }

        // Try using transpiled functions
        if (itemData.upgrade_description_args && itemData.upgrade_description_args.length > 0 &&
            typeof DescriptionRuntime !== 'undefined' && typeof DescriptionFunctions !== 'undefined') {
            try {
                const effectiveStats = this.getEffectiveHeroStats();
                const ctx = {
                    currentItem: {
                        id: itemData.id,
                        level: itemData.level || 1,
                        config: itemData.raw_data || { bonuses: [] }
                    },
                    currentHero: {
                        heroStat: effectiveStats
                    }
                };

                return DescriptionRuntime.formatDescription(
                    itemData.upgrade_description_template,
                    itemData.upgrade_description_args,
                    ctx
                );
            } catch (e) {
                console.warn('[EquipmentManager] Upgrade description error, falling back:', e);
            }
        }

        // Fallback to pre-formatted
        return itemData.upgrade_description || itemData.upgrade_description_template || '';
    },

    /**
     * Format a skill description using the transpiled description pipeline.
     * @param {Object} skillData - Skill data with description_template and description_args
     * @param {number} level - Skill level (1-based, default 1)
     * @returns {string} Formatted description
     */
    formatSkillDescription(skillData, level = 1) {
        // If no args, return template as-is (no placeholders to fill)
        if (!skillData.description_args || skillData.description_args.length === 0) {
            return skillData.description_template || '';
        }

        // Use transpiled functions - no fallback, errors should be visible
        if (typeof DescriptionRuntime === 'undefined' || typeof DescriptionFunctions === 'undefined') {
            console.error('[EquipmentManager] DescriptionRuntime or DescriptionFunctions not loaded');
            return '';
        }

        // Get level-specific parameters from raw_data
        const params = skillData.raw_data?.parametersPerLevel || [];
        const levelData = params[level - 1] || params[0] || {};

        // Create context for the transpiled functions
        // Note: skill functions expect bonuses directly on currentSkill (not in config)
        const ctx = {
            currentSkill: {
                id: skillData.skillId || skillData.id,
                level: level,
                ...levelData  // Spread levelData so bonuses are directly accessible
            },
            currentHero: {
                heroStat: this.getEffectiveHeroStats()
            }
        };

        return DescriptionRuntime.formatDescription(
            skillData.description_template,
            skillData.description_args,
            ctx
        );
    },

    /**
     * Format a subskill description using the transpiled description pipeline.
     * @param {Object} subskillData - Subskill data with description_template and description_args
     * @returns {string} Formatted description
     */
    formatSubskillDescription(subskillData) {
        // If no args, return template as-is (no placeholders to fill)
        if (!subskillData.description_args || subskillData.description_args.length === 0) {
            return subskillData.description_template || '';
        }

        // Use transpiled functions - no fallback, errors should be visible
        if (typeof DescriptionRuntime === 'undefined' || typeof DescriptionFunctions === 'undefined') {
            console.error('[EquipmentManager] DescriptionRuntime or DescriptionFunctions not loaded');
            return '';
        }

        // Create context for the transpiled functions
        // Subskills use currentSubSkill context (not currentSkill)
        const ctx = {
            currentSubSkill: {
                id: subskillData.id,
                ...subskillData.raw_data  // Spread raw_data so bonuses are accessible
            },
            currentHero: {
                heroStat: this.getEffectiveHeroStats()
            }
        };

        return DescriptionRuntime.formatDescription(
            subskillData.description_template,
            subskillData.description_args,
            ctx
        );
    },

    /**
     * Format a spell description using the transpiled description pipeline.
     * @param {Object} spellData - Spell data with description_template and description_args
     * @param {number} level - Spell level (1-based, default 1)
     * @returns {string} Formatted description
     */
    formatSpellDescription(spellData, level = 1) {
        // Prefer computed description if no args
        if (!spellData.description_args || spellData.description_args.length === 0) {
            return spellData.description || spellData.description_template || '';
        }

        // Use transpiled functions
        if (typeof DescriptionRuntime !== 'undefined' && typeof DescriptionFunctions !== 'undefined') {
            try {
                // Create context for the transpiled functions
                const ctx = {
                    currentMagic: {
                        id: spellData.id,
                        level: level,
                        school: spellData.school,
                        config: spellData.raw_data || {}
                    },
                    currentHero: {
                        stats: this.getEffectiveHeroStats()
                    }
                };

                return DescriptionRuntime.formatDescription(
                    spellData.description_template,
                    spellData.description_args,
                    ctx
                );
            } catch (e) {
                console.warn('[EquipmentManager] Spell description error, falling back:', e);
            }
        }

        // Fallback to pre-computed description
        return spellData.description || spellData.description_template || '';
    },

    /**
     * Update all equipped items' descriptions based on current effective stats
     */
    updateAllDescriptions() {
        for (const [slotId, itemData] of Object.entries(heroBuild.equipment.slots)) {
            if (itemData && (
                (itemData.description_args && itemData.description_args.length > 0) ||
                (itemData.description_values && itemData.description_values.length > 0)
            )) {
                itemData.description = this.formatItemDescription(itemData);
            }
        }
        // Re-render equipment UI to show updated descriptions
        this.updateUI();

        // Also update spell descriptions (hero stats may affect spell calculations)
        if (typeof SpellBookManager !== 'undefined') {
            SpellBookManager.updateAllDescriptions();
        }
    },

    maxAllUpgrades() {
        for (const [slotId, itemData] of Object.entries(heroBuild.equipment.slots)) {
            if (itemData && itemData.max_level > 1) {
                itemData.level = itemData.max_level;
                const rawBonuses = itemData.raw_data?.bonuses || [];
                itemData.bonuses = this.calculateBonusesForLevel(rawBonuses, itemData.max_level - 1);
            }
        }
        this.updateAllDescriptions();
        this.updateUI();
        this.updateDustDisplay();
    },

    resetAllUpgrades() {
        for (const [slotId, itemData] of Object.entries(heroBuild.equipment.slots)) {
            if (itemData) {
                itemData.level = 1;
                const rawBonuses = itemData.raw_data?.bonuses || [];
                itemData.bonuses = this.calculateBonusesForLevel(rawBonuses, 0);
            }
        }
        this.updateAllDescriptions();
        this.updateUI();
        this.updateDustDisplay();
    },

    /**
     * Set the upgrade level of an equipped item
     * @param {string} slotId - Slot identifier (e.g., 'weapon', 'ring-1')
     * @param {number} newLevel - New upgrade level (1-based)
     */
    setItemLevel(slotId, newLevel) {
        const itemData = heroBuild.equipment.slots[slotId];
        if (!itemData) return;

        // Clamp level between 1 and max_level
        const maxLevel = itemData.max_level || 1;
        const clampedLevel = Math.max(1, Math.min(newLevel, maxLevel));

        // Update the level
        itemData.level = clampedLevel;

        // Recalculate bonuses based on new level
        // Note: level is 1-based, but calculation uses 0-based (level - 1)
        const rawBonuses = itemData.raw_data?.bonuses || [];
        itemData.bonuses = this.calculateBonusesForLevel(rawBonuses, clampedLevel - 1);

        // Update all descriptions (hero stats and item levels may affect them)
        this.updateAllDescriptions();

        // Update UI to reflect changes (updateUI handles hiding active tooltip)
        this.updateUI();
        this.updateDustDisplay();

        // Re-show tooltip for the same slot so user sees updated content immediately
        const slotElement = document.getElementById(`slot-${slotId}`);
        if (slotElement && typeof Tooltip !== 'undefined') {
            Tooltip.show(slotElement);
        }
    },

    init() {
        // Setup click handlers for all equipment slots
        const equipSlots = document.querySelectorAll('.equip-slot[data-slot-type]');
        equipSlots.forEach(slot => {
            const slotId = slot.id.replace('slot-', '');
            const slotType = slot.dataset.slotType;

            slot.onclick = () => {
                ItemSelectionModal.open(slotId, slotType);
            };
        });

        // Initial UI update to show any pre-equipped items
        this.updateUI();
        this.updateDustDisplay();
    },

    equipItem(slotId, itemData) {
        // Initialize level (defaults to 1 if not provided)
        const initialLevel = itemData.level || 1;

        // Get bonuses from raw_data (API format) or bonuses_raw (legacy)
        const rawBonuses = itemData.raw_data?.bonuses || itemData.bonuses_raw || itemData.bonuses || [];

        // Calculate initial bonuses based on level
        const calculatedBonuses = this.calculateBonusesForLevel(
            rawBonuses,
            initialLevel - 1  // Convert 1-based to 0-based
        );

        // Update heroBuild state
        heroBuild.equipment.slots[slotId] = {
            id: itemData.id,
            name: itemData.name,
            icon: itemData.icon,
            slot: itemData.slot,
            rarity: itemData.rarity,
            bonuses: calculatedBonuses,
            item_set: itemData.item_set,
            max_level: itemData.max_level || 1,
            cost_base: itemData.cost_base || 0,
            cost_per_level: itemData.cost_per_level || 0,
            description: itemData.description,
            description_template: itemData.description_template,
            description_values: itemData.description_values,
            description_args: itemData.description_args || [],
            upgrade_description: itemData.upgrade_description || '',
            upgrade_description_template: itemData.upgrade_description_template || '',
            upgrade_description_args: itemData.upgrade_description_args || [],
            narrative_description: itemData.narrative_description || '',
            raw_data: itemData.raw_data,
            level: initialLevel
        };

        // Update all descriptions (hero stats may have changed)
        this.updateAllDescriptions();

        // Update UI
        this.updateUI();
        this.updateDustDisplay();

        // Update item-granted spells (magic scrolls grant spells)
        if (typeof SpellBookManager !== 'undefined') {
            SpellBookManager.updateSkillGrantedSpells();
        }
    },

    unequipItem(slotId) {
        // Remove from heroBuild state
        heroBuild.equipment.slots[slotId] = null;

        // Update all descriptions (hero stats may have changed)
        this.updateAllDescriptions();

        // Update UI
        this.updateUI();
        this.updateDustDisplay();

        // Update item-granted spells (removed item's spells should disappear)
        if (typeof SpellBookManager !== 'undefined') {
            SpellBookManager.updateSkillGrantedSpells();
        }
    },

    updateUI() {
        // Hide active tooltip before regenerating DOM content
        // (Tooltip system moves tooltips to document.body; if we regenerate the slot's
        // innerHTML, the old tooltip stays orphaned in body showing stale content)
        if (typeof Tooltip !== 'undefined') {
            Tooltip.hideActive();
        }

        // Update all equipment slots to show equipped items or empty state
        for (const [slotId, itemData] of Object.entries(heroBuild.equipment.slots)) {
            const slotElement = document.getElementById(`slot-${slotId}`);
            if (!slotElement) continue;

            if (itemData) {
                // Show equipped item with tooltip
                const rarityColor = ItemSelectionModal.rarityColors[itemData.rarity] || '#ffffff';

                // Get current level and max level
                const currentLevel = itemData.level || 1;
                const maxLevel = itemData.max_level || 1;

                // Always calculate description dynamically using formatItemDescription
                const descriptionText = this.formatItemDescription(itemData, currentLevel) ||
                                       (itemData.bonuses || []).join(', ') ||
                                       'No description';
                const bonusesHTML = `<div class="bonus-line">${descriptionText}</div>`;

                // Calculate dust costs
                const canLevelUp = currentLevel < maxLevel;
                const canLevelDown = currentLevel > 1;
                const upgradeCost = canLevelUp ? this.calculateDustCost(itemData, currentLevel + 1) - this.calculateDustCost(itemData, currentLevel) : 0;
                const downgradeSavings = canLevelDown ? this.calculateDustCost(itemData, currentLevel) - this.calculateDustCost(itemData, currentLevel - 1) : 0;

                const upgradeControlsHTML = `
                    <div class="tooltip-level">Level ${currentLevel}/${maxLevel}</div>
                    <div class="tooltip-upgrade-row">
                        <button class="tooltip-upgrade-btn ${!canLevelUp ? 'disabled' : ''}"
                                onclick="event.stopPropagation(); if (${canLevelUp}) EquipmentManager.setItemLevel('${slotId}', ${currentLevel + 1});">
                            ⏫ ${upgradeCost} <img src="/media/gamedata/resources/dust.png" class="dust-icon-small" alt="dust">
                        </button>
                        <button class="tooltip-upgrade-btn ${!canLevelDown ? 'disabled' : ''}"
                                onclick="event.stopPropagation(); if (${canLevelDown}) EquipmentManager.setItemLevel('${slotId}', ${currentLevel - 1});">
                            ⏬ ${downgradeSavings} <img src="/media/gamedata/resources/dust.png" class="dust-icon-small" alt="dust">
                        </button>
                    </div>
                    <button class="tooltip-remove-btn" onclick="event.stopPropagation(); EquipmentManager.unequipItem('${slotId}');">
                        Remove Item
                    </button>
                `;

                // Add narrative description (flavor text) if available
                const narrativeHTML = itemData.narrative_description
                    ? `<div class="tooltip-narrative">${itemData.narrative_description}</div>`
                    : '';

                // Generate set bonus section if item belongs to a set
                let setHTML = '';
                if (itemData.item_set) {
                    const setData = ItemSetManager.getSetForItem(itemData.id);
                    if (setData) {
                        const equippedCount = ItemSetManager.getEquippedSetItemCount(itemData.item_set);
                        const totalItems = setData.items.length;

                        // Build bonus list with active/inactive styling
                        const bonusListHTML = setData.bonuses.map(bonus => {
                            const isActive = equippedCount >= bonus.requiredItemsAmount;
                            const description = ItemSetManager.formatBonusDescription(setData, bonus);
                            const activeClass = isActive ? 'set-bonus-active' : 'set-bonus-inactive';
                            return `
                                <div class="set-bonus-item ${activeClass}">
                                    <span class="set-bonus-req">(${bonus.requiredItemsAmount})</span>
                                    <span class="set-bonus-desc">${description}</span>
                                </div>
                            `;
                        }).join('');

                        setHTML = `
                            <div class="tooltip-set-section">
                                <div class="set-header">
                                    <span class="set-name">${setData.name}</span>
                                    <span class="set-progress">(${equippedCount}/${totalItems})</span>
                                </div>
                                <div class="set-bonus-list">
                                    ${bonusListHTML}
                                </div>
                            </div>
                        `;
                    }
                }

                slotElement.classList.add('has-tooltip');
                slotElement.dataset.tooltipPlacement = 'right';
                slotElement.innerHTML = `
                    <img src="/media/gamedata/items/${itemData.icon}.png"
                         alt="${itemData.name}"
                         style="opacity: 1; width: 90%; height: 90%;">
                    <div class="tooltip tooltip-item">
                        <div class="tooltip-header">
                            <span class="item-name" style="color: ${rarityColor}">${itemData.name}</span>
                            <span class="item-rarity">${itemData.rarity}</span>
                        </div>
                        <div class="tooltip-bonuses">
                            ${bonusesHTML}
                        </div>
                        ${narrativeHTML}
                        ${setHTML}
                        ${upgradeControlsHTML}
                    </div>
                `;
                slotElement.style.borderColor = rarityColor;

                // Add/remove upgrade glow class based on level
                if (currentLevel > 1) {
                    slotElement.classList.add('item-upgraded');
                } else {
                    slotElement.classList.remove('item-upgraded');
                }
            } else {
                // Show empty slot with default icon
                slotElement.classList.remove('has-tooltip');
                delete slotElement.dataset.tooltipPlacement;
                const slotType = slotElement.dataset.slotType;
                const defaultIcons = {
                    'unique': 'slot_unique.png',
                    'head': 'slot_head.png',
                    'back': 'slot_cloak.png',
                    'armor': 'slot_armor.png',
                    'weapon': 'slot_left_hand.png',
                    'shield': 'slot_right_hand.png',
                    'belt': 'slot_belt.png',
                    'boots': 'slot_boots.png',
                    'ring': 'slot_ring.png',
                    'accessory': 'slot_item.png'
                };

                const defaultIcon = defaultIcons[slotType] || 'slot_item.png';

                slotElement.innerHTML = `
                    <img src="/media/gamedata/ui/${defaultIcon}" alt="${slotType}">
                `;
                slotElement.style.borderColor = '#3a4555';
                slotElement.classList.remove('item-upgraded');
            }
        }
    }
};

const ItemSetManager = {
    // Cached item sets data from API
    itemSets: [],  // Array of {id, name, items, bonuses, raw_data}
    itemToSetMap: {},  // Map of item_id -> set data for quick lookup

    async init() {
        try {
            const response = await fetch('/api/item-sets/');
            const data = await response.json();
            this.itemSets = data.item_sets || [];

            // Build item -> set lookup map
            this.itemToSetMap = {};
            for (const set of this.itemSets) {
                for (const itemId of set.items) {
                    this.itemToSetMap[itemId] = set;
                }
            }

            console.log(`[ItemSetManager] Loaded ${this.itemSets.length} item sets`);
        } catch (error) {
            console.error('[ItemSetManager] Failed to load item sets:', error);
        }
    },

    /**
     * Get the set that an item belongs to, if any.
     * @param {string} itemId - The item's id_key
     * @returns {object|null} Set data or null
     */
    getSetForItem(itemId) {
        return this.itemToSetMap[itemId] || null;
    },

    /**
     * Count unique equipped items from a specific set.
     * Two copies of the same item count as 1.
     * @param {string} setId - The set's id_key
     * @returns {number} Number of unique items equipped from this set
     */
    getEquippedSetItemCount(setId) {
        const equippedItemIds = new Set();
        for (const slotData of Object.values(heroBuild.equipment.slots)) {
            if (slotData && slotData.item_set === setId) {
                equippedItemIds.add(slotData.id);  // Set ensures uniqueness
            }
        }
        return equippedItemIds.size;
    },

    /**
     * Get all items from a set and their equipped status.
     * @param {string} setId - The set's id_key
     * @returns {Array} Array of {itemId, equipped: boolean}
     */
    getSetItemsStatus(setId) {
        const set = this.itemSets.find(s => s.id === setId);
        if (!set) return [];

        const equippedIds = new Set();
        for (const slotData of Object.values(heroBuild.equipment.slots)) {
            if (slotData && slotData.item_set === setId) {
                equippedIds.add(slotData.id);
            }
        }

        return set.items.map(itemId => ({
            itemId,
            equipped: equippedIds.has(itemId)
        }));
    },

    /**
     * Format a set bonus description using the transpiler system.
     * @param {object} setData - The full set data object
     * @param {object} bonus - The specific bonus object
     * @returns {string} Formatted description
     */
    formatBonusDescription(setData, bonus) {
        if (!bonus.description_template) return '';

        // Create context for CurrentItemSet
        const ctx = {
            currentItemSet: {
                id: setData.id,
                config: setData.raw_data
            },
            currentHero: {
                heroStat: EquipmentManager.getEffectiveHeroStats()
            }
        };

        try {
            return DescriptionRuntime.formatDescription(
                bonus.description_template,
                bonus.description_args || [],
                ctx
            );
        } catch (e) {
            console.error('[ItemSetManager] Error formatting bonus:', e);
            return bonus.description_template;
        }
    },

    /**
     * Get active set bonuses (those with enough items equipped).
     * @param {string} setId - The set's id_key
     * @returns {Array} Array of active bonus objects
     */
    getActiveSetBonuses(setId) {
        const set = this.itemSets.find(s => s.id === setId);
        if (!set) return [];

        const equippedCount = this.getEquippedSetItemCount(setId);
        return set.bonuses.filter(bonus => equippedCount >= bonus.requiredItemsAmount);
    },

    /**
     * Calculate total hero stat bonuses from all active set bonuses.
     * @returns {object} Map of stat_name -> total bonus value
     */
    getActiveSetStatBonuses() {
        const bonuses = {};

        for (const set of this.itemSets) {
            const equippedCount = this.getEquippedSetItemCount(set.id);
            if (equippedCount === 0) continue;

            for (const bonus of set.bonuses) {
                if (equippedCount < bonus.requiredItemsAmount) continue;

                // Process hero bonuses
                for (const heroBonus of (bonus.heroBonuses || [])) {
                    if (heroBonus.type === 'heroStat') {
                        const [statName, value] = heroBonus.parameters;
                        const numValue = parseFloat(value) || 0;
                        bonuses[statName] = (bonuses[statName] || 0) + numValue;
                    }
                }
            }
        }

        return bonuses;
    }
};

const SpellBookManager = {
    // State
    availableSpells: [],
    bonusSpells: [],  // Skill-granted spells (not learnable, from API)
    skillGrantedSpells: [],  // Currently active skill-granted spells
    schools: [],
    equippedSpells: new Array(5).fill(null), // 5 initial slots
    currentSlotIndex: null,
    currentSchoolFilter: 'all',  // Filter for picker modal (school)
    currentModalTypeFilter: 'all',  // Filter for picker modal (combat/global)
    currentBookFilter: null,  // Filter for the spell book view (school) - null means all
    currentTypeFilter: null,  // Filter for the spell book view (combat/global) - null means all
    showEquippedInPicker: false,  // Toggle for showing equipped spells in picker modal
    isAddingNewSlot: false,

    // Initialize - fetch spells from API
    async init() {
        try {
            const response = await fetch('/api/spells/available/');
            const data = await response.json();
            this.availableSpells = data.spells || [];
            this.bonusSpells = data.bonus_spells || [];
            this.schools = data.schools || [];
            console.log(`[SpellBookManager] Loaded ${this.availableSpells.length} spells, ${this.bonusSpells.length} bonus spells`);
        } catch (error) {
            console.error('[SpellBookManager] Failed to load spells:', error);
        }

        // Load starting spells from hero card data attribute
        this.loadStartingSpells();

        // Check current skills for skill-granted spells
        this.updateSkillGrantedSpells();

        this.renderSchoolTabs();
        this.rebuildSpellGrid();  // Build the initial grid with just the "+" button
    },

    // Load starting spells from hero card data attribute
    loadStartingSpells() {
        const heroCard = document.querySelector('[data-hero-starting-spells]');
        if (!heroCard) return;

        try {
            const startingSpells = JSON.parse(heroCard.dataset.heroStartingSpells || '[]');
            if (!startingSpells.length) return;

            console.log(`[SpellBookManager] Loading ${startingSpells.length} starting spells`);

            // Clear the initial empty slots
            this.equippedSpells = [];

            // Add each starting spell
            startingSpells.forEach(spellData => {
                // The spellData from the template already has all the info we need
                // It matches the structure from api_available_spells
                this.equippedSpells.push({
                    spell: spellData,
                    upgradeLevel: spellData.upgrade_level || 1,
                    isStartingSpell: true  // Mark as starting spell - cannot be removed
                });
                console.log(`[SpellBookManager] Added starting spell: ${spellData.name} (${spellData.id})`);
            });
        } catch (error) {
            console.error('[SpellBookManager] Error loading starting spells:', error);
        }
    },

    // Update granted spells based on current hero skills and equipped items
    updateSkillGrantedSpells() {
        const newGrantedSpells = [];
        const addedSpellIds = new Set();

        // Helper to find spell data in both bonus and available spells
        const findSpellData = (spellId) => {
            return this.bonusSpells.find(s => s.id === spellId) ||
                   this.availableSpells.find(s => s.id === spellId);
        };

        // Helper to add a granted spell (avoiding duplicates)
        const addGrantedSpell = (spellId, source, sourceId) => {
            if (addedSpellIds.has(spellId)) return;
            const spellData = findSpellData(spellId);
            if (spellData) {
                addedSpellIds.add(spellId);
                newGrantedSpells.push({
                    spell: spellData,
                    upgradeLevel: 1,
                    isSkillGrantedSpell: true,
                    grantingSource: source,  // 'skill' or 'item'
                    grantingSourceId: sourceId
                });
            }
        };

        // Check skills for heroMagicAddition bonuses
        heroBuild.skills.forEach(skill => {
            if (!skill) return;

            // Check main skill bonuses (from parametersPerLevel)
            if (skill.raw_data) {
                const rawData = skill.raw_data;
                const parametersPerLevel = rawData.parametersPerLevel || [];

                // Get bonuses for current skill level (levels are 1-indexed, array is 0-indexed)
                const levelIndex = (skill.level || 1) - 1;
                const levelParams = parametersPerLevel[levelIndex];
                if (levelParams && levelParams.bonuses) {
                    levelParams.bonuses.forEach(bonus => {
                        if (bonus.type === 'heroMagicAddition' && bonus.parameters && bonus.parameters[0]) {
                            addGrantedSpell(bonus.parameters[0], 'skill', skill.skillId);
                        }
                    });
                }
            }

            // Check subskill bonuses
            const subskillRawDataArray = skill.subskillRawData || [];
            subskillRawDataArray.forEach((subskillRaw, idx) => {
                if (!subskillRaw) return;
                const bonuses = subskillRaw.bonuses || [];
                bonuses.forEach(bonus => {
                    if (bonus.type === 'heroMagicAddition' && bonus.parameters && bonus.parameters[0]) {
                        addGrantedSpell(bonus.parameters[0], 'subskill', skill.subskills[idx]);
                    }
                });
            });
        });

        // Check equipped items for heroMagicAddition bonuses
        Object.values(heroBuild.equipment.slots).forEach(itemData => {
            if (!itemData || !itemData.raw_data) return;

            const bonuses = itemData.raw_data.bonuses || [];
            bonuses.forEach(bonus => {
                if (bonus.type === 'heroMagicAddition' && bonus.parameters && bonus.parameters[0]) {
                    addGrantedSpell(bonus.parameters[0], 'item', itemData.id);
                }
            });
        });

        // Check if anything changed
        const oldIds = this.skillGrantedSpells.map(s => s.spell.id).sort().join(',');
        const newIds = newGrantedSpells.map(s => s.spell.id).sort().join(',');

        if (oldIds !== newIds) {
            console.log(`[SpellBookManager] Granted spells updated: ${newGrantedSpells.length} spells`);
            this.skillGrantedSpells = newGrantedSpells;
            this.rebuildSpellGrid();
        }
    },

    // Render school tabs for filtering the spell book (no "All" - toggle to deselect)
    renderSchoolTabs() {
        const container = document.getElementById('spell-school-tabs');
        if (!container) return;

        container.innerHTML = this.schools.map(school => `
            <button class="spell-school-tab" data-school="${school.id}" onclick="SpellBookManager.toggleBookSchoolFilter('${school.id}')">
                ${school.name.replace(' Magic', '')}
            </button>
        `).join('');
    },

    // Toggle the spell book school filter (clicking active one turns it off)
    toggleBookSchoolFilter(schoolId) {
        // Toggle: if already active, clear filter; otherwise set it
        this.currentBookFilter = (this.currentBookFilter === schoolId) ? null : schoolId;

        // Update active tab
        document.querySelectorAll('#spell-school-tabs .spell-school-tab').forEach(tab => {
            tab.classList.toggle('active', tab.dataset.school === this.currentBookFilter);
        });

        // Apply all filters
        this.applyAllFilters();
    },

    // Toggle the spell book type filter (clicking active one turns it off)
    toggleBookTypeFilter(type) {
        // Toggle: if already active, clear filter; otherwise set it
        this.currentTypeFilter = (this.currentTypeFilter === type) ? null : type;

        // Update active button
        document.querySelectorAll('.spell-type-filters .spell-type-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.type === this.currentTypeFilter);
        });

        // Apply all filters
        this.applyAllFilters();
    },

    // Apply both school and type filters (null means show all)
    applyAllFilters() {
        document.querySelectorAll('.spell-slot').forEach((slot) => {
            // Skip the add button
            if (slot.classList.contains('spell-slot-add')) {
                slot.classList.remove('filtered-out');
                return;
            }

            // Get the correct spell array and index based on slot type
            const slotIndex = parseInt(slot.dataset.slotIndex, 10);
            const isSkillGranted = slot.classList.contains('skill-granted');
            const spellArray = isSkillGranted ? this.skillGrantedSpells : this.equippedSpells;
            const equipped = spellArray[slotIndex];

            if (!equipped || !equipped.spell) {
                // Empty slots: always show
                slot.classList.remove('filtered-out');
            } else {
                // Check school filter (null means all)
                const matchesSchool = this.currentBookFilter === null ||
                                      equipped.spell.school === this.currentBookFilter;

                // Check type filter (null means all)
                const matchesType = this.currentTypeFilter === null ||
                                   equipped.spell.spell_type === this.currentTypeFilter;

                // Must match BOTH filters
                slot.classList.toggle('filtered-out', !(matchesSchool && matchesType));
            }
        });
    },

    // Open the spell picker modal
    openSpellPicker(slotIndex) {
        this.isAddingNewSlot = false; // We're replacing/filling an existing slot
        this.currentSlotIndex = slotIndex;
        this.renderSpellPicker();
    },

    // Add new spell slot
    addNewSpell() {
        this.isAddingNewSlot = true;
        this.currentSlotIndex = this.equippedSpells.length; // Next available index
        this.renderSpellPicker();
    },

    // Render the modal with spell list
    renderSpellPicker() {
        const container = document.getElementById('skill-modal-container');

        // Sync modal filters from spell book filters (convert null to 'all' for modal)
        this.currentSchoolFilter = this.currentBookFilter || 'all';
        this.currentModalTypeFilter = this.currentTypeFilter || 'all';

        container.innerHTML = `
            <div class="modal-overlay" onclick="SpellBookManager.closeSpellPicker()">
                <div class="skill-modal" onclick="event.stopPropagation()">
                    <div class="modal-header">
                        <h2>Select Spell</h2>
                        <div class="modal-controls">
                            <input type="text"
                                   id="spell-search-input"
                                   class="skill-search"
                                   placeholder="Search spells..."
                                   oninput="SpellBookManager.filterSpells(this.value)">
                            <label class="scroll-toggle">
                                <input type="checkbox"
                                       id="show-equipped-toggle"
                                       ${this.showEquippedInPicker ? 'checked' : ''}
                                       onchange="SpellBookManager.toggleShowEquipped(this.checked)">
                                Show in book
                            </label>
                        </div>
                    </div>
                    <div class="spell-school-tabs-modal">
                        <button class="spell-school-tab-modal ${this.currentSchoolFilter === 'all' ? 'active' : ''}" data-school="all" onclick="SpellBookManager.filterBySchool('all')">All</button>
                        ${this.schools.map(school => `
                            <button class="spell-school-tab-modal ${this.currentSchoolFilter === school.id ? 'active' : ''}" data-school="${school.id}" onclick="SpellBookManager.filterBySchool('${school.id}')">
                                ${school.name.replace(' Magic', '')}
                            </button>
                        `).join('')}
                    </div>
                    <div class="spell-type-tabs-modal">
                        <button class="spell-type-tab-modal ${this.currentModalTypeFilter === 'all' ? 'active' : ''}" data-type="all" onclick="SpellBookManager.filterModalByType('all')">All</button>
                        <button class="spell-type-tab-modal ${this.currentModalTypeFilter === 'combat' ? 'active' : ''}" data-type="combat" onclick="SpellBookManager.filterModalByType('combat')">Combat</button>
                        <button class="spell-type-tab-modal ${this.currentModalTypeFilter === 'global' ? 'active' : ''}" data-type="global" onclick="SpellBookManager.filterModalByType('global')">Global Map</button>
                    </div>
                    <div class="skill-list" id="spell-picker-list">
                        ${this.renderSpellList(this.getFilteredSpells())}
                    </div>
                </div>
            </div>
        `;
    },

    // Check if a spell is already equipped (manually or via skill/item)
    isSpellEquipped(spellId) {
        return this.equippedSpells.some(eq => eq && eq.spell && eq.spell.id === spellId) ||
               this.skillGrantedSpells.some(eq => eq && eq.spell && eq.spell.id === spellId);
    },

    // Render the list of spells
    renderSpellList(spells) {
        if (spells.length === 0) {
            return '<div class="no-results">No spells found</div>';
        }

        return spells.map(spell => {
            const isEquipped = this.isSpellEquipped(spell.id);
            const description = this.formatSpellDescription(spell, 1);
            const clickHandler = isEquipped ? '' : `onclick="SpellBookManager.selectSpell('${spell.id}')"`;
            const disabledClass = isEquipped ? ' spell-option-disabled' : '';

            return `
                <div class="skill-option spell-option${disabledClass}" ${clickHandler}>
                    <div class="skill-icon-wrapper spell-icon-round">
                        <img src="/media/gamedata/spells/${spell.icon || spell.id}.png"
                             class="skill-icon"
                             alt="${spell.id}"
                             onerror="SpellBookManager.handleSpellIconError(this, '${spell.icon || spell.id}')">
                        ${isEquipped ? '<div class="spell-equipped-badge">In Book</div>' : ''}
                    </div>
                    <div class="skill-info">
                        <div class="skill-name">${this.formatSpellName(spell.id_key || spell.id)}</div>
                        <div class="skill-meta" style="color: #7ec8e3; font-size: 0.8rem; margin-bottom: 6px;">
                            ${spell.school_display} • Tier ${spell.level} • ${spell.spell_type === 'global' ? 'Global Map' : 'Combat'}
                        </div>
                        <div class="skill-desc spell-description">${description}</div>
                    </div>
                </div>
            `;
        }).join('');
    },

    // Filter by search text
    filterSpells(searchText) {
        document.getElementById('spell-picker-list').innerHTML = this.renderSpellList(this.getFilteredSpells(searchText));
    },

    // Filter by school tab
    filterBySchool(schoolId) {
        this.currentSchoolFilter = schoolId;

        // Update active tab
        document.querySelectorAll('.spell-school-tab-modal').forEach(tab => {
            tab.classList.toggle('active', tab.dataset.school === schoolId);
        });

        // Clear search input when changing school
        const searchInput = document.getElementById('spell-search-input');
        if (searchInput) searchInput.value = '';

        document.getElementById('spell-picker-list').innerHTML = this.renderSpellList(this.getFilteredSpells());
    },

    // Filter by type tab (Combat/Global Map)
    filterModalByType(type) {
        this.currentModalTypeFilter = type;

        // Update active tab
        document.querySelectorAll('.spell-type-tab-modal').forEach(tab => {
            tab.classList.toggle('active', tab.dataset.type === type);
        });

        // Clear search input when changing type
        const searchInput = document.getElementById('spell-search-input');
        if (searchInput) searchInput.value = '';

        document.getElementById('spell-picker-list').innerHTML = this.renderSpellList(this.getFilteredSpells());
    },

    // Get spells filtered by current school, type, and equipped toggle
    getFilteredSpells(searchText = '') {
        let spells = this.availableSpells;

        // Filter by school
        if (this.currentSchoolFilter !== 'all') {
            spells = spells.filter(s => s.school === this.currentSchoolFilter);
        }

        // Filter by type (combat/global)
        if (this.currentModalTypeFilter !== 'all') {
            spells = spells.filter(s => s.spell_type === this.currentModalTypeFilter);
        }

        // Filter by search text
        if (searchText) {
            const search = searchText.toLowerCase();
            spells = spells.filter(spell => {
                const formattedName = this.formatSpellName(spell.id_key || spell.id).toLowerCase();
                return formattedName.includes(search) ||
                       spell.id.toLowerCase().includes(search) ||
                       spell.school_display.toLowerCase().includes(search);
            });
        }

        // Filter out equipped spells if toggle is off
        if (!this.showEquippedInPicker) {
            spells = spells.filter(spell => !this.isSpellEquipped(spell.id));
        }

        return spells;
    },

    // Toggle showing equipped spells in picker
    toggleShowEquipped(checked) {
        this.showEquippedInPicker = checked;
        const searchText = document.getElementById('spell-search-input')?.value || '';
        document.getElementById('spell-picker-list').innerHTML = this.renderSpellList(this.getFilteredSpells(searchText));
    },

    // Select a spell and assign it to the slot
    selectSpell(spellId) {
        const spell = this.availableSpells.find(s => s.id === spellId);
        if (!spell) {
            console.error('[SpellBookManager] Spell not found:', spellId);
            return;
        }

        if (this.isAddingNewSlot) {
            // Create a new slot with the spell
            this.equippedSpells.push({
                spell: spell,
                upgradeLevel: 1
            });
            // Create new slot element in the DOM
            this.createNewSlotElement(this.equippedSpells.length - 1);
        } else {
            // Fill existing empty slot
            this.equippedSpells[this.currentSlotIndex] = {
                spell: spell,
                upgradeLevel: 1  // Start at level 1
            };
            this.updateSlot(this.currentSlotIndex);
        }

        console.log(`[SpellBookManager] Equipped ${spell.id}, total slots: ${this.equippedSpells.length}`);

        this.isAddingNewSlot = false;
        this.closeSpellPicker();
    },

    // Helper to format spell name from id_key
    formatSpellName(idKey) {
        // Convert "day_01_magic_blessing" to "Blessing"
        // Remove school prefix and number, capitalize
        const parts = idKey.split('_');
        // Find the meaningful part (usually after "magic")
        const magicIndex = parts.indexOf('magic');
        if (magicIndex >= 0 && magicIndex < parts.length - 1) {
            return parts.slice(magicIndex + 1).map(word =>
                word.charAt(0).toUpperCase() + word.slice(1)
            ).join(' ');
        }
        // Fallback: just capitalize all parts
        return parts.map(word =>
            word.charAt(0).toUpperCase() + word.slice(1)
        ).join(' ');
    },

    // Get fallback icon path for _special variants
    getFallbackIconPath(spellId) {
        // Strip _special suffix to get base spell icon
        if (spellId.endsWith('_special')) {
            return `/media/gamedata/spells/${spellId.replace(/_special$/, '')}.png`;
        }
        // For other cases, try a generic fallback
        return '/media/gamedata/ui/magic_icon.png';
    },

    // Handle spell icon load error - try fallback
    handleSpellIconError(img, spellId) {
        const fallbackPath = this.getFallbackIconPath(spellId);
        if (img.src !== fallbackPath && !img.dataset.triedFallback) {
            img.dataset.triedFallback = 'true';
            img.src = fallbackPath;
        }
    },

    // Format spell description using the description pipeline
    formatSpellDescription(spell, upgradeLevel = 1) {
        // Check if description runtime is available
        if (typeof DescriptionRuntime === 'undefined' || typeof DescriptionFunctions === 'undefined') {
            console.warn('[SpellBookManager] Description runtime not available');
            return spell.description_template || 'No description available';
        }

        try {
            // Get effective hero stats
            const effectiveStats = EquipmentManager ? EquipmentManager.getEffectiveHeroStats() : {};

            // Create context for the spell using the same structure as HeroState
            // The transpiled functions expect data like targetMechanics to be directly on currentMagic
            // Use the magicDealer for the current upgrade level (0-indexed)
            const magicDealers = spell.raw_data?.battleMagic?.magicDealers || [];
            const dealerIndex = Math.min(upgradeLevel - 1, magicDealers.length - 1);
            const magicDealer = magicDealers[Math.max(0, dealerIndex)] || {};
            // For world magic spells, get usageLimit from worldMagic settings
            const worldMagicSettings = spell.raw_data?.worldMagic?.magicSettings?.[0] || {};

            const ctx = {
                currentMagic: {
                    id: spell.id_key || spell.id,
                    upgradeLevel: upgradeLevel - 1,  // 0-indexed
                    level: spell.level,
                    school: spell.school,
                    // Spread magicDealer data so targetMechanics is directly accessible
                    ...magicDealer,
                    // Include worldMagic settings (for usageLimit, etc.)
                    ...worldMagicSettings,
                    // Also include the full raw_data for functions that need config
                    config: spell.raw_data || {},
                },
                currentHero: {
                    // Use 'heroStat' as the key - this is what transpiled functions expect
                    heroStat: effectiveStats,
                    stats: effectiveStats,  // Keep for backwards compatibility
                    getSpellPower: (school) => {
                        // Base spell power + school-specific bonuses
                        return effectiveStats.spellPower || 0;
                    }
                }
            };

            // Select the correct description template/args for this upgrade level
            // spell.descriptions is an array where index 0 = level 1, index 1 = level 2, etc.
            const descriptions = spell.descriptions || [];
            const descIndex = Math.min(upgradeLevel - 1, descriptions.length - 1);
            const levelDesc = descriptions[Math.max(0, descIndex)] || {};

            // Use level-specific template/args, falling back to legacy fields
            const template = levelDesc.description_template || spell.description_template || '';
            const args = levelDesc.description_args || spell.description_args || [];

            if (!template) {
                return 'No description available';
            }

            return DescriptionRuntime.formatDescription(template, args, ctx);
        } catch (error) {
            console.warn('[SpellBookManager] Error formatting spell description:', error);
            return spell.description_template || 'Error loading description';
        }
    },

    // Create a new slot element in the DOM
    createNewSlotElement(index) {
        const grid = document.getElementById('spell-grid');
        const equipped = this.equippedSpells[index];
        const spell = equipped.spell;
        const description = this.formatSpellDescription(spell, equipped.upgradeLevel);
        const maxLevel = spell.max_upgrade_level || 3;
        const currentLevel = equipped.upgradeLevel;

        const slotDiv = document.createElement('div');
        slotDiv.className = 'spell-slot equipped has-tooltip';
        slotDiv.dataset.slotIndex = index;
        slotDiv.dataset.tooltipPlacement = 'left';
        const isStarting = equipped.isStartingSpell;
        slotDiv.innerHTML = `
            <img src="/media/gamedata/spells/${spell.icon || spell.id_key || spell.id}.png"
                 alt="${spell.id_key || spell.id}"
                 class="spell-icon"
                 onerror="SpellBookManager.handleSpellIconError(this, '${spell.icon || spell.id_key || spell.id}')">
            <button class="spell-slot-remove" onclick="event.stopPropagation(); SpellBookManager.removeSpell(${index})" ${isStarting ? 'disabled' : ''}>×</button>
            ${isStarting ? '<div class="spell-starting-badge">Starting</div>' : ''}
            <div class="spell-level-badge">${currentLevel}</div>
            <div class="tooltip tooltip-spell">
                <div class="tooltip-title tooltip-title--blue">${spell.name || this.formatSpellName(spell.id_key || spell.id)}</div>
                <div class="tooltip-subtitle">${spell.school_display}</div>
                <div class="tooltip-meta">${spell.spell_type === 'global' ? 'Global Map' : 'Combat'} Spell</div>
                <div class="tooltip-meta">Tier ${spell.level}</div>
                <div class="tooltip-highlight tooltip-level">Level ${currentLevel}/${maxLevel}</div>
                <div class="tooltip-section">
                    <div class="tooltip-text">${description}</div>
                </div>
                <div class="tooltip-actions">
                    <button class="tooltip-action-btn"
                            onclick="event.stopPropagation(); SpellBookManager.upgradeSpell(${index})"
                            ${currentLevel >= maxLevel ? 'disabled' : ''}>
                        Upgrade
                    </button>
                    <button class="tooltip-action-btn"
                            onclick="event.stopPropagation(); SpellBookManager.downgradeSpell(${index})"
                            ${currentLevel <= 1 ? 'disabled' : ''}>
                        Downgrade
                    </button>
                    <button class="tooltip-action-btn tooltip-remove-btn"
                            onclick="event.stopPropagation(); SpellBookManager.removeSpell(${index})"
                            ${isStarting ? 'disabled' : ''}>
                        Remove
                    </button>
                </div>
            </div>
        `;

        // Add click handler for spell replacement
        slotDiv.addEventListener('click', () => this.openSpellPicker(index));

        // Insert before the "+" add button (which should always be last)
        const addButton = grid.querySelector('.spell-slot-add');
        if (addButton) {
            grid.insertBefore(slotDiv, addButton);
        } else {
            grid.appendChild(slotDiv);
        }
    },

    // Update a single slot's UI to show equipped spell or empty state
    updateSlot(index) {
        const slotElement = document.querySelector(`.spell-slot[data-slot-index="${index}"]`);
        if (!slotElement) return;

        const equipped = this.equippedSpells[index];

        if (equipped === null) {
            // Empty slot
            slotElement.innerHTML = '<span class="add-text">+</span>';
            slotElement.classList.remove('equipped');
        } else {
            // Filled slot with spell
            const spell = equipped.spell;
            const description = this.formatSpellDescription(spell, equipped.upgradeLevel);
            const maxLevel = spell.max_upgrade_level || 3;
            const currentLevel = equipped.upgradeLevel;
            const isStarting = equipped.isStartingSpell;

            slotElement.classList.add('has-tooltip');
            slotElement.dataset.tooltipPlacement = 'left';
            slotElement.innerHTML = `
                <img src="/media/gamedata/spells/${spell.icon || spell.id_key || spell.id}.png"
                     alt="${spell.id_key || spell.id}"
                     class="spell-icon"
                     onerror="SpellBookManager.handleSpellIconError(this, '${spell.icon || spell.id_key || spell.id}')">
                <button class="spell-slot-remove" onclick="event.stopPropagation(); SpellBookManager.removeSpell(${index})" ${isStarting ? 'disabled' : ''}>×</button>
                ${isStarting ? '<div class="spell-starting-badge">Starting</div>' : ''}
                <div class="spell-level-badge">${currentLevel}</div>
                <div class="tooltip tooltip-spell">
                    <div class="tooltip-title tooltip-title--blue">${spell.name || this.formatSpellName(spell.id_key || spell.id)}</div>
                    <div class="tooltip-subtitle">${spell.school_display}</div>
                    <div class="tooltip-meta">${spell.spell_type === 'global' ? 'Global Map' : 'Combat'} Spell</div>
                    <div class="tooltip-meta">Tier ${spell.level}</div>
                    <div class="tooltip-highlight tooltip-level">Level ${currentLevel}/${maxLevel}</div>
                    <div class="tooltip-section">
                        <div class="tooltip-text">${description}</div>
                    </div>
                    <div class="tooltip-actions">
                        <button class="tooltip-action-btn"
                                onclick="event.stopPropagation(); SpellBookManager.upgradeSpell(${index})"
                                ${currentLevel >= maxLevel ? 'disabled' : ''}>
                            Upgrade
                        </button>
                        <button class="tooltip-action-btn"
                                onclick="event.stopPropagation(); SpellBookManager.downgradeSpell(${index})"
                                ${currentLevel <= 1 ? 'disabled' : ''}>
                            Downgrade
                        </button>
                        <button class="tooltip-action-btn tooltip-remove-btn"
                                onclick="event.stopPropagation(); SpellBookManager.removeSpell(${index})"
                                ${isStarting ? 'disabled' : ''}>
                            Remove
                        </button>
                    </div>
                </div>
            `;
            slotElement.classList.add('equipped');
        }

        // Reapply all filters
        this.applyAllFilters();
    },

    // Upgrade spell to next level
    upgradeSpell(index, isSkillGranted = false) {
        const spellArray = isSkillGranted ? this.skillGrantedSpells : this.equippedSpells;
        const equipped = spellArray[index];
        if (!equipped) return;

        const maxLevel = equipped.spell.max_upgrade_level || 3;
        if (equipped.upgradeLevel >= maxLevel) return;

        equipped.upgradeLevel++;
        console.log(`[SpellBookManager] Upgraded spell to level ${equipped.upgradeLevel}`);

        this.updateSlotInPlace(index, isSkillGranted);
    },

    // Downgrade spell to previous level
    downgradeSpell(index, isSkillGranted = false) {
        const spellArray = isSkillGranted ? this.skillGrantedSpells : this.equippedSpells;
        const equipped = spellArray[index];
        if (!equipped) return;

        if (equipped.upgradeLevel <= 1) return;

        equipped.upgradeLevel--;
        console.log(`[SpellBookManager] Downgraded spell to level ${equipped.upgradeLevel}`);

        this.updateSlotInPlace(index, isSkillGranted);
    },

    // Update a slot in place without rebuilding the grid
    updateSlotInPlace(index, isSkillGranted = false) {
        const selector = isSkillGranted
            ? `.spell-slot.skill-granted[data-slot-index="${index}"]`
            : `.spell-slot[data-slot-index="${index}"]:not(.skill-granted)`;
        const slotElement = document.querySelector(selector);
        if (!slotElement) return;

        const spellArray = isSkillGranted ? this.skillGrantedSpells : this.equippedSpells;
        const equipped = spellArray[index];
        const spell = equipped.spell;
        const description = this.formatSpellDescription(spell, equipped.upgradeLevel);
        const maxLevel = spell.max_upgrade_level || 4;
        const currentLevel = equipped.upgradeLevel;

        // Update level badge (always in slot)
        const levelBadge = slotElement.querySelector('.spell-level-badge');
        if (levelBadge) levelBadge.textContent = currentLevel;

        // Helper to find tooltip elements - check slot first, then active tooltip in body
        // (Tooltip system moves tooltips to document.body when visible)
        const findTooltipElement = (selector) => {
            // Try slot first (tooltip not visible or not moved yet)
            let el = slotElement.querySelector(selector);
            if (el) return el;
            // Try active tooltip in document.body (tooltip is visible and was moved)
            const activeTooltip = document.body.querySelector('.tooltip[style*="display: block"]');
            if (activeTooltip) {
                el = activeTooltip.querySelector(selector);
            }
            return el;
        };

        // Update tooltip level
        const tooltipLevel = findTooltipElement('.tooltip-level');
        if (tooltipLevel) tooltipLevel.textContent = `Level ${currentLevel}/${maxLevel}`;

        // Update tooltip description
        const tooltipDesc = findTooltipElement('.tooltip-text');
        if (tooltipDesc) tooltipDesc.innerHTML = description;

        // Update button states
        const upgradeBtn = findTooltipElement('.tooltip-action-btn:first-child');
        const downgradeBtn = findTooltipElement('.tooltip-action-btn:nth-child(2)');
        if (upgradeBtn) upgradeBtn.disabled = currentLevel >= maxLevel;
        if (downgradeBtn) downgradeBtn.disabled = currentLevel <= 1;
    },

    // Remove spell from slot
    removeSpell(index) {
        const equipped = this.equippedSpells[index];
        if (!equipped) return;

        // Cannot remove starting spells
        if (equipped.isStartingSpell) {
            console.log(`[SpellBookManager] Cannot remove starting spell`);
            return;
        }

        const spellName = this.formatSpellName(equipped.spell.id_key || equipped.spell.id);
        console.log(`[SpellBookManager] Removing spell ${spellName} from slot ${index}`);

        // Remove the spell and shift remaining spells up
        this.equippedSpells.splice(index, 1);
        this.rebuildSpellGrid();
    },

    // Max all equipped spells
    maxAllSpells() {
        let upgraded = 0;
        this.equippedSpells.forEach((equipped, index) => {
            if (equipped !== null) {
                const maxLevel = equipped.spell.max_upgrade_level || 3;
                if (equipped.upgradeLevel < maxLevel) {
                    equipped.upgradeLevel = maxLevel;
                    upgraded++;
                }
            }
        });

        if (upgraded > 0) {
            console.log(`[SpellBookManager] Maxed ${upgraded} spells`);
            this.rebuildSpellGrid();
        }
    },

    // Reset all equipped spells to level 1
    resetAllSpells() {
        let reset = 0;
        this.equippedSpells.forEach((equipped, index) => {
            if (equipped !== null && equipped.upgradeLevel > 1) {
                equipped.upgradeLevel = 1;
                reset++;
            }
        });

        if (reset > 0) {
            console.log(`[SpellBookManager] Reset ${reset} spells to level 1`);
            this.rebuildSpellGrid();
        }
    },

    // Rebuild the entire grid - shows filled spells + one "+" button to add more
    rebuildSpellGrid() {
        const grid = document.getElementById('spell-grid');
        grid.innerHTML = '';

        // Remove any null entries (clean up the array)
        this.equippedSpells = this.equippedSpells.filter(e => e !== null);

        // Helper to render a spell slot
        const renderSpellSlot = (equipped, index, isSkillGranted = false) => {
            const slotDiv = document.createElement('div');
            slotDiv.className = 'spell-slot equipped has-tooltip' + (isSkillGranted ? ' skill-granted' : '');
            slotDiv.dataset.slotIndex = index;
            slotDiv.dataset.tooltipPlacement = 'left';
            if (isSkillGranted) {
                slotDiv.dataset.skillGranted = 'true';
            }

            const spell = equipped.spell;
            const description = this.formatSpellDescription(spell, equipped.upgradeLevel);
            const maxLevel = spell.max_upgrade_level || 4;
            const currentLevel = equipped.upgradeLevel;
            const isStarting = equipped.isStartingSpell;
            const isLocked = isStarting || isSkillGranted;

            // Badge text based on spell source
            let badgeHtml = '';
            if (isStarting) {
                badgeHtml = '<div class="spell-starting-badge">Starting</div>';
            } else if (isSkillGranted) {
                let source = 'Skill';
                if (equipped.grantingSource === 'item') source = 'Scroll';
                else if (equipped.grantingSource === 'subskill') source = 'Subskill';
                badgeHtml = `<div class="spell-skill-badge">${source}</div>`;
            }

            slotDiv.innerHTML = `
                <img src="/media/gamedata/spells/${spell.icon || spell.id_key || spell.id}.png"
                     alt="${spell.id_key || spell.id}"
                     class="spell-icon"
                     onerror="SpellBookManager.handleSpellIconError(this, '${spell.icon || spell.id_key || spell.id}')">
                ${!isLocked ? `<button class="spell-slot-remove" onclick="event.stopPropagation(); SpellBookManager.removeSpell(${index})">×</button>` : ''}
                ${badgeHtml}
                <div class="spell-level-badge">${currentLevel}</div>
                <div class="tooltip tooltip-spell">
                    <div class="tooltip-title tooltip-title--blue">${spell.name || this.formatSpellName(spell.id_key || spell.id)}</div>
                    <div class="tooltip-subtitle">${spell.school_display}</div>
                    <div class="tooltip-meta">${spell.spell_type === 'global' ? 'Global Map' : 'Combat'} Spell</div>
                    <div class="tooltip-meta">Tier ${spell.level}</div>
                    <div class="tooltip-highlight tooltip-level">Level ${currentLevel}/${maxLevel}</div>
                    <div class="tooltip-section">
                        <div class="tooltip-text">${description}</div>
                    </div>
                    <div class="tooltip-actions">
                        <button class="tooltip-action-btn"
                                onclick="event.stopPropagation(); SpellBookManager.upgradeSpell(${index}, ${isSkillGranted})"
                                ${currentLevel >= maxLevel ? 'disabled' : ''}>Upgrade</button>
                        <button class="tooltip-action-btn"
                                onclick="event.stopPropagation(); SpellBookManager.downgradeSpell(${index}, ${isSkillGranted})"
                                ${currentLevel <= 1 ? 'disabled' : ''}>Downgrade</button>
                        ${!isLocked ? `<button class="tooltip-action-btn tooltip-remove-btn"
                                onclick="event.stopPropagation(); SpellBookManager.removeSpell(${index})">Remove</button>` : ''}
                    </div>
                </div>
            `;

            // Click to replace this spell (only for non-locked spells)
            if (!isLocked) {
                slotDiv.addEventListener('click', () => this.openSpellPicker(index));
            }
            grid.appendChild(slotDiv);
        };

        // Render all equipped spells (user-selected)
        this.equippedSpells.forEach((equipped, index) => {
            renderSpellSlot(equipped, index, false);
        });

        // Render skill-granted spells (from skills)
        this.skillGrantedSpells.forEach((equipped, index) => {
            renderSpellSlot(equipped, index, true);
        });

        // Add the "+" button at the end to add new spells
        const addSlot = document.createElement('div');
        addSlot.className = 'spell-slot spell-slot-add';
        addSlot.innerHTML = '<span class="add-text">+</span>';
        addSlot.addEventListener('click', () => this.addNewSpell());
        grid.appendChild(addSlot);

        this.applyAllFilters();
    },

    // Update all spell descriptions (called when hero stats change)
    updateAllDescriptions() {
        console.log('[SpellBookManager] Updating all spell descriptions');

        // Rebuild the grid to recalculate all descriptions
        this.rebuildSpellGrid();
    },

    // Close the modal
    closeSpellPicker() {
        this.currentSlotIndex = null;
        this.isAddingNewSlot = false;
        document.getElementById('skill-modal-container').innerHTML = '';
    }
};

const ArmyManager = {
    currentSlotIndex: null,
    currentFactionTab: null,  // Currently selected faction in picker
    allFactions: [],  // All factions data from API

    // Initialize the army panel
    async init() {
        console.log('[ArmyManager] Initializing...');

        // Get hero faction from heroBuild (already set by SkillManager)
        const faction = heroBuild.heroFaction;
        if (!faction) {
            console.error('[ArmyManager] No faction found');
            return;
        }

        // Load ALL units from all factions
        await this.loadAllUnits();

        // Set default faction tab to hero's faction
        this.currentFactionTab = faction;

        // Get starting squad from hero card
        const heroCard = document.querySelector('[data-hero-faction]');
        const startSquadData = heroCard?.dataset.heroStartSquad;

        if (startSquadData) {
            try {
                const startSquad = JSON.parse(startSquadData);
                this.populateStartingArmy(startSquad);
            } catch (error) {
                console.error('[ArmyManager] Error parsing start squad:', error);
            }
        }

        // Bind click events on unit slots - always open picker to select/replace unit
        document.querySelectorAll('.unit-slot').forEach(slot => {
            slot.addEventListener('click', () => {
                const slotIndex = parseInt(slot.dataset.slotIndex, 10);
                this.openUnitPicker(slotIndex);
            });
        });

        // Set up tooltip callbacks for unit tooltips
        this.setupTooltipCallbacks();

        this.render();
    },

    // Setup tooltip callbacks for auto-focus and save on close
    setupTooltipCallbacks() {
        const self = this;

        // On tooltip show: focus the stack input if it's a unit tooltip
        Tooltip.setOnShow((tooltip, trigger) => {
            if (!tooltip.classList.contains('tooltip-unit')) return;

            const stackInput = tooltip.querySelector('.unit-stack-input');
            if (stackInput) {
                // Small delay to ensure tooltip is fully visible
                setTimeout(() => {
                    stackInput.focus();
                    stackInput.select();
                }, 50);

                // Handle Enter key to save and update descriptions (without closing)
                stackInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        self.saveAndUpdateTooltip(tooltip, stackInput);
                    }
                });
            }
        });

        // On tooltip hide: save the stack count if valid
        Tooltip.setOnHide((tooltip, trigger) => {
            if (!tooltip.classList.contains('tooltip-unit')) return;

            const slotIndex = parseInt(tooltip.dataset.unitSlotIndex, 10);
            if (isNaN(slotIndex)) return;

            const stackInput = tooltip.querySelector('.unit-stack-input');
            if (!stackInput) return;

            const newCount = parseInt(stackInput.value, 10);
            const armySlot = heroBuild.army[slotIndex];

            // Only update if valid positive integer and different from current
            if (!isNaN(newCount) && newCount > 0 && armySlot && armySlot.count !== newCount) {
                armySlot.count = newCount;
                self.render();
                console.log(`[ArmyManager] Updated stack count for slot ${slotIndex} to ${newCount}`);
            }
        });
    },

    // Save stack count and update tooltip descriptions in-place (without closing)
    saveAndUpdateTooltip(tooltip, stackInput) {
        const slotIndex = parseInt(tooltip.dataset.unitSlotIndex, 10);
        if (isNaN(slotIndex)) return;

        const newCount = parseInt(stackInput.value, 10);
        const armySlot = heroBuild.army[slotIndex];

        // Validate: must be a positive integer
        if (isNaN(newCount) || newCount <= 0) {
            // Reset to current value if invalid
            stackInput.value = armySlot?.count || 1;
            return;
        }

        if (!armySlot) return;

        // Update the count in the data model
        armySlot.count = newCount;

        // Update the slot display (the badge showing count)
        const slots = document.querySelectorAll('.unit-slot');
        const slot = slots[slotIndex];
        if (slot) {
            const countBadge = slot.querySelector('.unit-count');
            if (countBadge) {
                countBadge.textContent = newCount;
            }
        }

        // Update army value display
        this.updateArmyValue();

        // Update the abilities section in the tooltip with new stack count
        const abilitiesRow = tooltip.querySelector('.tooltip-abilities-row');
        if (abilitiesRow && armySlot.unitData) {
            abilitiesRow.outerHTML = this.buildTooltipAbilitiesHtml(armySlot.unitData, newCount);
        }

        console.log(`[ArmyManager] Updated stack count for slot ${slotIndex} to ${newCount}`);

        // Keep focus on the input and select the text
        stackInput.focus();
        stackInput.select();
    },

    // Fetch all units from all factions
    async loadAllUnits() {
        try {
            const response = await fetch('/api/units/all/');
            const data = await response.json();
            this.allFactions = data.factions || [];

            // Also maintain backwards-compatible factionUnits for hero's faction
            const heroFaction = this.allFactions.find(f => f.slug === heroBuild.heroFaction);
            if (heroFaction) {
                heroBuild.factionUnits = heroFaction.units_by_tier || {};
            }

            console.log(`[ArmyManager] Loaded ${this.allFactions.length} factions with units`);
        } catch (error) {
            console.error('[ArmyManager] Failed to load units:', error);
            this.allFactions = [];
            heroBuild.factionUnits = {};
        }
    },

    // Helper: Find unit by ID across ALL factions
    findUnitById(unitId) {
        for (const faction of this.allFactions) {
            for (const tier of Object.keys(faction.units_by_tier || {})) {
                const units = faction.units_by_tier[tier];
                const unit = units.find(u => u.id === unitId);
                if (unit) return unit;
            }
        }
        return null;
    },

    // Helper: Get units for a specific faction
    getFactionUnits(factionSlug) {
        const faction = this.allFactions.find(f => f.slug === factionSlug);
        return faction ? faction.units_by_tier : {};
    },

    // Helper: Get all units as flat array
    getAllUnits() {
        const allUnits = [];
        for (const faction of this.allFactions) {
            for (const tier of Object.keys(faction.units_by_tier || {})) {
                allUnits.push(...faction.units_by_tier[tier]);
            }
        }
        return allUnits;
    },

    // Populate starting army from startSquad data
    populateStartingArmy(startSquad) {
        console.log('[ArmyManager] Populating starting army:', startSquad);

        startSquad.forEach((entry, index) => {
            if (index >= 7) return; // Only 7 slots

            const unitId = entry.sid;
            const minCount = entry.min || 0;
            const maxCount = entry.max || minCount;
            const count = Math.floor((minCount + maxCount) / 2); // Use average

            // Find unit data
            const unitData = this.findUnitById(unitId);
            if (unitData) {
                heroBuild.army[index] = {
                    unitId: unitId,
                    count: count,
                    unitData: unitData,
                    isStartingUnit: true
                };
                console.log(`[ArmyManager] Added starting unit: ${unitData.name} x${count}`);
            }
        });

        this.render();
    },

    // Render the army slots
    render() {
        const slots = document.querySelectorAll('.unit-slot');

        slots.forEach((slot, index) => {
            const armySlot = heroBuild.army[index];

            // Clear previous content
            slot.innerHTML = '';
            slot.classList.remove('filled');

            if (armySlot && armySlot.unitData) {
                // Filled slot
                slot.classList.add('filled', 'has-tooltip');
                slot.dataset.tooltipPlacement = 'top';

                const unit = armySlot.unitData;

                slot.innerHTML = `
                    <img src="${unit.icon_url}" alt="${unit.name}" class="unit-icon" onerror="this.src='/media/gamedata/ui/unit_placeholder.png'">
                    <span class="unit-count">${armySlot.count}</span>
                    <button class="unit-remove-btn" onclick="event.stopPropagation(); ArmyManager.removeUnitFromSlot(${slot.dataset.slotIndex});" title="Remove unit">&times;</button>
                    <div class="tooltip tooltip-unit" data-unit-slot-index="${index}">
                        <div class="tooltip-header">
                            <span class="tooltip-title">${unit.name}</span>
                            <input type="number" class="unit-stack-input" value="${armySlot.count}" min="1" step="1" title="Stack size">
                        </div>
                        <div class="tooltip-tier">Tier ${unit.tier} · ${this.formatUnitType(unit)}</div>
                        <div class="unit-stat-bar tooltip-stat-bar">${this.buildStatBar(unit.stats)}</div>
                        ${this.buildTooltipAbilitiesHtml(unit, armySlot.count)}
                        <div class="tooltip-value">${unit.squad_value} gold</div>
                        ${unit.description ? `<div class="tooltip-description">${unit.description}</div>` : ''}
                    </div>
                `;
            } else {
                // Empty slot
                slot.classList.remove('has-tooltip');
                delete slot.dataset.tooltipPlacement;
                slot.innerHTML = '<span class="add-text">+</span>';
            }
        });

        this.updateArmyValue();
    },

    // Format unit type display
    formatUnitType(unit) {
        const types = [];
        if (unit.attack_type === 'ranged') types.push('Ranged');
        else if (unit.attack_type === 'long_reach') types.push('Long Reach');
        else if (unit.attack_type === 'magic') types.push('Magic');
        else types.push('Melee');
        if (unit.move_type === 'fly') types.push('Flying');
        return types.join(', ');
    },

    // Stat icons SVGs (inline for reliability)
    statIcons: {
        hp: `<img src="/media/gamedata/ui/unit_health.png" alt="HP" style="width: 18px; height: 18px; vertical-align: middle;">`,
        damage: `<img src="/media/gamedata/ui/unit_damage.png" alt="Damage" style="width: 18px; height: 18px; vertical-align: middle;">`,
        offence: `<img src="/media/gamedata/ui/unit_attack.png" alt="Attack" style="width: 18px; height: 18px; vertical-align: middle;">`,
        defence: `<img src="/media/gamedata/ui/unit_defence.png" alt="Defence" style="width: 18px; height: 18px; vertical-align: middle;">`,
        luck: `<img src="/media/gamedata/ui/unit_luck.png" alt="Luck" style="width: 18px; height: 18px; vertical-align: middle;">`,
        morale: `<img src="/media/gamedata/ui/unit_moral.png" alt="Morale" style="width: 18px; height: 18px; vertical-align: middle;">`,
        speed: `<img src="/media/gamedata/ui/unit_speed.png" alt="Speed" style="width: 18px; height: 18px; vertical-align: middle;">`,
        initiative: `<img src="/media/gamedata/ui/unit_init.png" alt="Initiative" style="width: 18px; height: 18px; vertical-align: middle;">`,
    },

    // Get stat icon HTML
    getStatIcon(stat) {
        return this.statIcons[stat] || '';
    },

    // Build stat bar HTML for unit card
    buildStatBar(stats) {
        const statOrder = ['hp', 'damage', 'offence', 'defence', 'luck', 'morale', 'speed', 'initiative'];
        const statLabels = {
            hp: 'Health',
            damage: 'Damage',
            offence: 'Attack',
            defence: 'Defence',
            luck: 'Luck',
            morale: 'Morale',
            speed: 'Speed',
            initiative: 'Initiative',
        };
        const statDescriptions = {
            hp: 'Hit points per creature',
            damage: 'Base damage dealt per attack',
            offence: 'Increases damage dealt',
            defence: 'Reduces damage taken',
            luck: 'Chance for critical hits',
            morale: 'Chance for extra actions',
            speed: 'Movement range in combat',
            initiative: 'Determines turn order',
        };

        // Format damage as range
        const damageValue = stats.damage_min === stats.damage_max
            ? stats.damage_min
            : `${stats.damage_min}-${stats.damage_max}`;

        const statValues = {
            hp: stats.hp,
            damage: damageValue,
            offence: stats.offence,
            defence: stats.defence,
            luck: stats.luck || 0,
            morale: stats.morale || 0,
            speed: stats.speed,
            initiative: stats.initiative,
        };

        return statOrder.map(stat => `
            <div class="unit-stat has-tooltip" data-tooltip-placement="top">
                <span class="unit-stat-icon">${this.getStatIcon(stat)}</span>
                <span class="unit-stat-value">${statValues[stat]}</span>
                <div class="tooltip">
                    <div class="tooltip-title">${statLabels[stat]}: ${statValues[stat]}</div>
                    <div class="tooltip-text">${statDescriptions[stat]}</div>
                </div>
            </div>
        `).join('');
    },

    // Extract raw ability data from unit's raw_data based on ability ID
    getRawAbilityData(abilityId, rawData) {
        if (!rawData || !abilityId) return null;

        // Parse ability ID format: unitId_type_index (e.g., "crossbowman_ability_0", "esquire_passive_0", "unit_aura")
        const passiveMatch = abilityId.match(/_passive_(\d+)$/);
        if (passiveMatch) {
            const index = parseInt(passiveMatch[1], 10);
            return rawData.passives?.[index] || null;
        }

        const abilityMatch = abilityId.match(/_ability_(\d+)$/);
        if (abilityMatch) {
            const index = parseInt(abilityMatch[1], 10);
            return rawData.abilities?.[index] || null;
        }

        if (abilityId.endsWith('_aura')) {
            return rawData.aura || null;
        }

        return null;
    },

    // Check if a description has failed resolutions (contains obvious "0" placeholders)
    hasFailedResolution(text) {
        if (!text) return false;
        // Patterns that indicate failed resolution: +0, -0, 0%, 0–0, etc.
        // Be careful not to flag valid ranges like "0 to 5" or "–5 to 0"
        const failurePatterns = [
            /[+\-–]\s*0\s*(?:%|$|[,\.])/,     // +0, -0, +0%, -0% (not followed by space/word)
            /\b0[–-]0\b/,                      // 0-0, 0–0 (damage ranges of zero)
            /\bby\s+0\b/,                      // "by 0", "increases by 0"
            /:\s*0\s+(?:round|turn|second)/i,  // ": 0 round(s)" (zero duration)
        ];
        return failurePatterns.some(pattern => pattern.test(text));
    },

    // Format ability description using DescriptionRuntime
    formatAbilityDescription(ability, unitData, stackCount = 1) {
        if (!ability.description_template) {
            return ability.name || '';
        }

        if (!ability.description_args || ability.description_args.length === 0) {
            return ability.description_template;
        }

        try {
            const rawData = unitData?.raw_data || {};
            const unitId = rawData.id || unitData?.id || '';

            // Use raw ability data from backend if available (includes upgrade variant fallback)
            // Otherwise fall back to index-based lookup for backwards compatibility
            let rawAbility = ability.raw_data || this.getRawAbilityData(ability.id, rawData);

            // Inject buff data into ability if missing (for functions like current_unit_ability_buff_duration)
            rawAbility = this.injectBuffDataIntoAbility(rawAbility, ability, unitId);

            // Deep clone passives and inject buff links so description functions can find them
            // Functions access paths like passives[0].actions[0].damageDealer.buff.sid
            const passives = this.injectBuffLinksIntoPassives(
                rawData.passives || [],
                ability.description_args,
                unitId
            );

            // Flatten stats to top level for description functions that expect ctx.currentUnit.damageMin
            // fullStacks is the actual stack count (defaults to 1 if not provided)
            // Note: Game uses fullStacks - 1 internally, so we pass count - 1 to match game behavior
            const currentUnit = {
                ...rawData,
                ...rawData.stats,  // Flatten stats (damageMin, damageMax, etc.) to top level
                passives: passives,  // Use enriched passives with buff links
                fullStacks: stackCount - 1,  // Game script adds 1 to this value
                startBattleFullStacks: stackCount - 1,
            };

            const ctx = {
                currentUnit: currentUnit,
                currentAbility: rawAbility || ability,
            };

            const resolved = DescriptionRuntime.formatDescription(
                ability.description_template,
                ability.description_args,
                ctx
            );

            // Debug logging for cavalry
            if (rawData.id && rawData.id.includes('cavalry')) {
                console.log('[DEBUG] Description resolved:', {
                    abilityId: ability.id,
                    template: ability.description_template?.substring(0, 50),
                    resolved: resolved?.substring(0, 100),
                    passivesLength: passives.length,
                    passive2HasBuff: passives[2]?.actions?.[0]?.damageDealer?.buff?.sid
                });
            }

            // If resolution produced obvious "0" placeholders, fall back to template
            // (This happens when base units lack the data structure that upgraded units have)
            if (this.hasFailedResolution(resolved)) {
                // Return template with placeholders stripped for cleaner display
                return ability.description_template.replace(/\{(\d+)\}/g, '?');
            }

            return resolved;
        } catch (e) {
            console.warn('[ArmyManager] Error formatting ability description:', e);
            return ability.description_template;
        }
    },

    /**
     * Inject buff links into passives so description functions can find them.
     * Description functions access paths like passives[n].actions[0].damageDealer.buff.sid
     * but our static data doesn't have this structure. This method creates it using
     * GameData.passiveBuffLinks which maps passive name keys to their linked buffs.
     *
     * Also handles cases where an ability exists in the ability list but its raw_data
     * passive doesn't exist (e.g., upgrade-only abilities shown on base units).
     */
    injectBuffLinksIntoPassives(passives, descriptionArgs, unitId) {
        if (!descriptionArgs) {
            return passives || [];
        }

        // Debug logging
        if (unitId && unitId.includes('cavalry')) {
            console.log('[DEBUG] injectBuffLinksIntoPassives:', {
                unitId,
                passivesCount: passives?.length,
                descriptionArgs,
                hasGameData: typeof GameData !== 'undefined',
                hasPassiveBuffLinks: typeof GameData !== 'undefined' && !!GameData.passiveBuffLinks
            });
        }

        // Extract base unit ID (remove _upg, _upg_alt suffixes)
        const baseUnitId = unitId ? unitId.replace(/_upg(_alt)?$/, '') : '';

        // Deep clone passives to avoid modifying original data
        const enrichedPassives = (passives || []).map(passive =>
            JSON.parse(JSON.stringify(passive))
        );

        // Find the maximum passive index referenced by description functions
        // Function names are like "unic_unit_{unitId}_passive_{N}"
        let maxPassiveIndex = enrichedPassives.length - 1;
        for (const funcName of descriptionArgs) {
            const match = funcName.match(/unic_unit_([^_]+(?:_[^_]+)*)_passive_(\d+)/);
            if (match) {
                const passiveNum = parseInt(match[2], 10);  // 1-based
                const passiveIndex = passiveNum - 1;  // 0-based
                if (passiveIndex > maxPassiveIndex) {
                    maxPassiveIndex = passiveIndex;
                }
            }
        }

        // Extend passives array if needed (for upgrade-only abilities on base units)
        while (enrichedPassives.length <= maxPassiveIndex) {
            enrichedPassives.push({ data: {} });
        }

        // Find ALL buff links for this unit (any passive index)
        // Different unit variants may have the same logical passive at different array indices
        // So we collect all buff links and inject them into ALL passives
        const allBuffLinks = [];
        if (typeof GameData !== 'undefined' && GameData.passiveBuffLinks) {
            for (let n = 1; n <= 10; n++) {
                const passiveKey = `${baseUnitId}_passive_${n}`;
                const buffLink = GameData.passiveBuffLinks[passiveKey];
                if (buffLink) {
                    allBuffLinks.push(buffLink);
                }
            }
        }

        // Debug logging for cavalry
        if (unitId && unitId.includes('cavalry')) {
            console.log(`[DEBUG] Found ${allBuffLinks.length} buff links for ${baseUnitId}:`,
                allBuffLinks.map(b => b.buffId));
        }

        // Inject ALL buff links into EVERY passive
        // This ensures the description function finds the data regardless of which index it checks
        for (let index = 0; index < enrichedPassives.length; index++) {
            const enriched = enrichedPassives[index];

            // Inject all buff links so functions can find them at any index
            for (const buffLink of allBuffLinks) {
                if (!enriched.actions) {
                    enriched.actions = [];
                }
                if (!enriched.actions[0]) {
                    enriched.actions[0] = {};
                }
                if (!enriched.actions[0].damageDealer) {
                    enriched.actions[0].damageDealer = {};
                }
                // Use the first buff link (most specific to this passive type)
                if (!enriched.actions[0].damageDealer.buff) {
                    enriched.actions[0].damageDealer.buff = {
                        sid: buffLink.buffId,
                        ...buffLink.buffData,
                        // Include duration at the buff level
                        ...(buffLink.duration !== undefined ? { duration: buffLink.duration } : {})
                    };
                }
            }
        }

        return enrichedPassives;
    },

    /**
     * Inject buff data into ability if missing.
     * For functions like current_unit_ability_buff_duration that access currentAbility.damageDealer.buff.duration
     */
    injectBuffDataIntoAbility(rawAbility, ability, unitId) {
        // If rawAbility already has complete buff data, return as-is
        if (rawAbility?.damageDealer?.buff?.duration !== undefined) {
            return rawAbility;
        }

        // Extract base unit ID and ability index from ability.id
        // Format: {unitId}_ability_{N} (0-based)
        const match = ability.id?.match(/^(.+?)(?:_upg(?:_alt)?)?_ability_(\d+)$/);
        if (!match) {
            return rawAbility || ability;
        }

        const baseUnitId = match[1].replace(/_upg(_alt)?$/, '');
        const abilityIndex = parseInt(match[2], 10);
        const abilityKey = `${baseUnitId}_ability_${abilityIndex + 1}`;  // Convert to 1-based for lookup

        // Look up buff link for this ability
        const buffLink = typeof GameData !== 'undefined' && GameData.passiveBuffLinks
            ? GameData.passiveBuffLinks[abilityKey]
            : null;

        if (!buffLink) {
            return rawAbility || ability;
        }

        // Clone and inject buff data
        const enriched = rawAbility ? JSON.parse(JSON.stringify(rawAbility)) : {};
        if (!enriched.damageDealer) {
            enriched.damageDealer = {};
        }
        if (!enriched.damageDealer.buff) {
            enriched.damageDealer.buff = {};
        }

        // Inject buff data from the link
        // Include duration at the buff level (this is where description functions expect it)
        enriched.damageDealer.buff = {
            ...enriched.damageDealer.buff,
            sid: buffLink.buffId,
            ...buffLink.buffData,
            // Duration is at the top level of buffLink, not inside buffData
            ...(buffLink.duration !== undefined ? { duration: buffLink.duration } : {})
        };

        return enriched;
    },

    // Build abilities row for tooltip (with nested tooltips for each ability)
    buildTooltipAbilitiesHtml(unit, stackCount = 1) {
        const allAbilities = [
            ...(unit.passives || []),
            ...(unit.actives || [])
        ];

        if (allAbilities.length === 0) return '';

        const abilitiesHtml = allAbilities.map(ability => {
            const iconHtml = ability.icon_url
                ? `<img src="${ability.icon_url}" alt="${ability.name}" class="tooltip-ability-icon">`
                : `<span class="tooltip-ability-placeholder">${ability.name.charAt(0)}</span>`;
            const description = this.formatAbilityDescription(ability, unit, stackCount) || '';
            const baseClass = ability.is_base_passive ? ' base-passive' : '';
            const typeClass = (unit.actives || []).includes(ability) ? 'active' : 'passive';

            return `
                <div class="tooltip-ability-item ${typeClass}${baseClass} has-tooltip" data-tooltip-placement="top">
                    ${iconHtml}
                    <div class="tooltip">
                        <div class="tooltip-title">${ability.name}</div>
                        ${description ? `<div class="tooltip-text">${description}</div>` : ''}
                    </div>
                </div>
            `;
        }).join('');

        return `<div class="tooltip-abilities-row">${abilitiesHtml}</div>`;
    },

    // Build side abilities HTML for new card layout (vertical column)
    buildSideAbilitiesHtml(abilities, type, unitData) {
        const self = this;
        if (!abilities || abilities.length === 0) return '';

        return abilities.map(ability => {
            const iconContent = ability.icon_url
                ? `<img src="${ability.icon_url}" alt="${ability.name}" class="ability-icon-img">`
                : '';
            const basePassiveClass = ability.is_base_passive ? ' base-passive' : '';

            return `
            <div class="ability-icon ${type}${basePassiveClass} has-tooltip" data-tooltip-placement="${type === 'passive' ? 'left' : 'right'}">
                ${iconContent}
                <div class="tooltip">
                    <div class="tooltip-title">${ability.name}</div>
                    <div class="tooltip-text">${self.formatAbilityDescription(ability, unitData) || (type === 'passive' ? 'Passive ability' : 'Active ability')}</div>
                </div>
            </div>
        `}).join('');
    },

    // Build abilities HTML for unit card (legacy row layout for editor modal)
    buildAbilitiesHtml(passives, actives, unitData) {
        const self = this;
        const passiveHtml = passives && passives.length > 0
            ? `<div class="unit-abilities-column passives">
                ${passives.map(p => {
                    const iconContent = p.icon_url
                        ? `<img src="${p.icon_url}" alt="${p.name}" class="ability-icon-img">`
                        : '';
                    const basePassiveClass = p.is_base_passive ? ' base-passive' : '';
                    return `
                    <div class="ability-icon passive${basePassiveClass} has-tooltip" data-tooltip-placement="top">
                        ${iconContent}
                        <div class="tooltip">
                            <div class="tooltip-title">${p.name}</div>
                            <div class="tooltip-text">${self.formatAbilityDescription(p, unitData) || 'Passive ability'}</div>
                        </div>
                    </div>
                `}).join('')}
               </div>`
            : '';

        const activeHtml = actives && actives.length > 0
            ? `<div class="unit-abilities-column actives">
                ${actives.map(a => {
                    const iconContent = a.icon_url
                        ? `<img src="${a.icon_url}" alt="${a.name}" class="ability-icon-img">`
                        : '';
                    return `
                    <div class="ability-icon active has-tooltip" data-tooltip-placement="top">
                        ${iconContent}
                        <div class="tooltip">
                            <div class="tooltip-title">${a.name}</div>
                            <div class="tooltip-text">${self.formatAbilityDescription(a, unitData) || 'Active ability'}</div>
                        </div>
                    </div>
                `}).join('')}
               </div>`
            : '';

        if (!passiveHtml && !activeHtml) return '';

        return `<div class="unit-abilities-row">${passiveHtml}${activeHtml}</div>`;
    },

    // Calculate and display total army value
    updateArmyValue() {
        const totalValue = this.getTotalArmyValue();
        const valueElement = document.getElementById('army-value');
        if (valueElement) {
            valueElement.textContent = `Value: ${totalValue}`;
        }
    },

    // Get total army value
    getTotalArmyValue() {
        return heroBuild.army.reduce((total, slot) => {
            if (slot && slot.unitData && slot.count) {
                return total + (slot.unitData.squad_value * slot.count);
            }
            return total;
        }, 0);
    },

    // Open unit picker modal with faction tabs
    openUnitPicker(slotIndex) {
        this.currentSlotIndex = slotIndex;

        if (!this.allFactions || this.allFactions.length === 0) {
            console.error('[ArmyManager] No factions available');
            return;
        }

        // Default to hero's faction tab
        if (!this.currentFactionTab) {
            this.currentFactionTab = heroBuild.heroFaction;
        }

        this.renderUnitPickerModal();
    },

    // Render the unit picker modal
    renderUnitPickerModal() {
        const unitsByTier = this.getFactionUnits(this.currentFactionTab);

        // Build faction tabs HTML
        const factionTabsHtml = this.allFactions.map(faction => `
            <button class="faction-tab ${faction.slug === this.currentFactionTab ? 'active' : ''}"
                    onclick="ArmyManager.switchFactionTab('${faction.slug}')"
                    title="${faction.name}">
                <img src="${faction.icon_url}" alt="${faction.name}" class="faction-tab-icon"
                     onerror="this.style.display='none'; this.nextElementSibling.style.display='inline'">
                <span class="faction-tab-name" style="display:none">${faction.name}</span>
            </button>
        `).join('');

        // Build units grid HTML with game-style card layout
        const unitsGridHtml = Object.keys(unitsByTier).sort((a, b) => a - b).map(tier => `
            <div class="unit-tier-group">
                <h3 class="unit-tier-header">Tier ${tier}</h3>
                <div class="unit-picker-grid">
                    ${unitsByTier[tier].map(unit => {
                        const statBarHtml = this.buildStatBar(unit.stats);
                        const passivesHtml = this.buildSideAbilitiesHtml(unit.passives, 'passive', unit);
                        const activesHtml = this.buildSideAbilitiesHtml(unit.actives, 'active', unit);

                        return `
                        <div class="unit-card" onclick="ArmyManager.selectUnit('${unit.id}')">
                            <div class="unit-card-header">
                                <div class="unit-card-name">${unit.name}</div>
                            </div>
                            <div class="unit-stat-bar">${statBarHtml}</div>
                            <div class="unit-card-portrait-section">
                                <div class="unit-abilities-side left">${passivesHtml}</div>
                                <img src="${unit.icon_url}" alt="${unit.name}" class="unit-card-portrait"
                                     onerror="this.src='/media/gamedata/ui/unit_placeholder.png'">
                                <div class="unit-abilities-side right">${activesHtml}</div>
                            </div>
                            <div class="unit-card-footer">${unit.squad_value} gold</div>
                        </div>
                    `}).join('')}
                </div>
            </div>
        `).join('');

        const modalHtml = `
            <div class="modal-overlay" onclick="ArmyManager.closeUnitPicker()">
                <div class="skill-modal unit-picker-modal" onclick="event.stopPropagation()">
                    <div class="faction-tabs">
                        ${factionTabsHtml}
                    </div>
                    <div class="skill-list unit-list">
                        ${unitsGridHtml}
                    </div>
                </div>
            </div>
        `;

        document.getElementById('skill-modal-container').innerHTML = modalHtml;
    },

    // Switch faction tab in unit picker
    switchFactionTab(factionSlug) {
        this.currentFactionTab = factionSlug;
        this.renderUnitPickerModal();
    },

    // Select a unit from picker
    selectUnit(unitId) {
        const unitData = this.findUnitById(unitId);
        if (!unitData) return;

        // Default count based on tier (higher tier = fewer units)
        const defaultCount = Math.max(1, Math.floor(20 / (unitData.tier || 1)));

        heroBuild.army[this.currentSlotIndex] = {
            unitId: unitId,
            count: defaultCount,
            unitData: unitData,
            isStartingUnit: false
        };

        this.render();
        this.closeUnitPicker();
    },

    // Open unit editor for existing unit
    openUnitEditor(slotIndex) {
        this.currentSlotIndex = slotIndex;
        const armySlot = heroBuild.army[slotIndex];

        if (!armySlot || !armySlot.unitData) return;

        const unit = armySlot.unitData;

        // Build stats object from unit data (handle both old and new property names)
        const stats = unit.stats || {
            hp: unit.health || unit.hp,
            offence: unit.attack || unit.offence,
            defence: unit.defence,
            damage_min: unit.damage_min,
            damage_max: unit.damage_max,
            initiative: unit.initiative,
            speed: unit.speed,
            luck: unit.luck || 0,
            morale: unit.morale || unit.moral || 0,
        };

        const statBarHtml = this.buildStatBar(stats);
        const abilitiesHtml = this.buildAbilitiesHtml(unit.passives, unit.actives, unit);

        const modalHtml = `
            <div class="modal-overlay" onclick="ArmyManager.closeUnitEditor()">
                <div class="modal-content unit-editor-modal" onclick="event.stopPropagation()">
                    <div class="modal-body">
                        <div class="unit-editor-content">
                            <div class="unit-editor-header">
                                <img src="${unit.icon_url || '/media/gamedata/units/' + (unit.icon || unit.id) + '.png'}"
                                     alt="${unit.name}" class="unit-editor-icon"
                                     onerror="this.src='/media/gamedata/ui/unit_placeholder.png'">
                                <div class="unit-editor-info">
                                    <span class="unit-editor-tier">Tier ${unit.tier || unit.level}</span>
                                    <span class="unit-editor-type">${this.formatUnitType(unit)}</span>
                                </div>
                            </div>
                            <div class="unit-stat-bar editor-stat-bar">${statBarHtml}</div>
                            ${abilitiesHtml}
                            ${unit.description ? `<div class="unit-description">${unit.description}</div>` : ''}
                            <div class="unit-editor-value">${unit.squad_value} gold per unit</div>
                            <div class="unit-count-control">
                                <label>Stack Size:</label>
                                <input type="number" id="unit-count-input" value="${armySlot.count}" min="1" max="9999">
                                <span class="unit-stack-value">= ${armySlot.count * unit.squad_value} gold</span>
                            </div>
                            <div class="unit-editor-actions">
                                <button class="btn btn-primary" onclick="ArmyManager.updateUnitCount()">Update</button>
                                <button class="btn btn-danger" onclick="ArmyManager.removeUnit()">Remove</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;

        document.getElementById('skill-modal-container').innerHTML = modalHtml;

        // Focus the input and update stack value on change
        setTimeout(() => {
            const input = document.getElementById('unit-count-input');
            if (input) {
                input.focus();
                input.select();
                input.addEventListener('input', () => {
                    const stackValueEl = document.querySelector('.unit-stack-value');
                    if (stackValueEl) {
                        const count = parseInt(input.value) || 0;
                        stackValueEl.textContent = `= ${count * unit.squad_value} gold`;
                    }
                });
            }
        }, 50);
    },

    // Update unit count
    updateUnitCount() {
        const input = document.getElementById('unit-count-input');
        const newCount = parseInt(input?.value || '1', 10);

        if (newCount > 0 && heroBuild.army[this.currentSlotIndex]) {
            heroBuild.army[this.currentSlotIndex].count = newCount;
            this.render();
            this.closeUnitEditor();
        }
    },

    // Remove unit from slot (used by editor modal)
    removeUnit() {
        if (this.currentSlotIndex !== null) {
            heroBuild.army[this.currentSlotIndex] = null;
            this.render();
            this.closeUnitEditor();
        }
    },

    // Remove unit from slot by index (used by remove button on slot)
    removeUnitFromSlot(slotIndex) {
        if (slotIndex !== undefined && heroBuild.army[slotIndex]) {
            heroBuild.army[slotIndex] = null;
            this.render();
        }
    },

    // Close unit picker
    closeUnitPicker() {
        this.currentSlotIndex = null;
        document.getElementById('skill-modal-container').innerHTML = '';
    },

    // Close unit editor
    closeUnitEditor() {
        this.currentSlotIndex = null;
        document.getElementById('skill-modal-container').innerHTML = '';
    }
};

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    SkillManager.init();
    AdvancedClassManager.init();
    ItemSetManager.init();  // Load item sets before equipment
    EquipmentManager.init();
    SpellBookManager.init();
    ArmyManager.init();

    // Close modal on Escape key
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
            SkillSelectionModal.close();
            SubskillSelectionModal.close();
            ItemSelectionModal.close();
            SpellBookManager.closeSpellPicker();
        }
    });
});
</script>
