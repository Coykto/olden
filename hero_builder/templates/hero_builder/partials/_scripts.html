<div id="skill-modal-container"></div>

<!-- Generated description functions from .script files -->
{% load static %}
<script src="{% static 'js/description-runtime.js' %}?v=8"></script>
<script src="{% static 'js/generated/game_data.js' %}?v=7"></script>
<script src="{% static 'js/generated/description_functions.js' %}?v=7"></script>
<script src="{% static 'js/hero-state.js' %}?v=7"></script>

<script>
// Auto-focus search bar when any modal opens
// Uses MutationObserver to handle all current and future modals
(function() {
    const modalContainer = document.getElementById('skill-modal-container');
    if (!modalContainer) return;

    const observer = new MutationObserver((mutations) => {
        for (const mutation of mutations) {
            if (mutation.addedNodes.length > 0) {
                const searchInput = modalContainer.querySelector('.skill-search');
                if (searchInput) {
                    setTimeout(() => searchInput.focus(), 50);
                }
                break;
            }
        }
    });

    observer.observe(modalContainer, { childList: true });
})();

// Client-side state for hero build
const heroBuild = {
    heroId: '',
    heroFaction: '',
    heroViewRadius: 6,  // Hero's view radius for item description calculations
    baseHeroLevel: 1,   // Starting hero level from DOM
    heroSpecialization: null,  // Raw specialization data with bonuses
    skills: [],  // Array of 8 slots: {skillId, level, subskills} or null
    startingSkillIds: [],
    startingSkillLevels: {},  // Map of skillId -> starting level, to track upgrades
    // Equipment state
    equipment: {
        slots: {
            'unique': null,      // { id, name, icon, level, maxLevel, ... }
            'head': null,
            'back': null,
            'armor': null,
            'weapon': null,      // left_hand
            'shield': null,      // right_hand
            'belt': null,
            'boots': null,
            'ring-1': null,
            'ring-2': null,
            'accessory-1': null, // item_slot
            'accessory-2': null,
            'accessory-3': null,
            'accessory-4': null
        },
        backpack: new Array(24).fill(null)  // 4x6 grid
    }
};

/**
 * Calculate current hero level based on skill changes.
 * Hero level = base level + new skills acquired + skill upgrades
 */
function getHeroLevel() {
    let level = heroBuild.baseHeroLevel;

    for (const skill of heroBuild.skills) {
        if (!skill) continue;

        const startingLevel = heroBuild.startingSkillLevels[skill.skillId];

        if (startingLevel === undefined) {
            // New skill (not in starting skills) - +1 for acquiring at Basic
            level += 1;
            // Plus any upgrades from Basic (level 1)
            level += (skill.level - 1);
        } else {
            // Starting skill - count only the upgrades from starting level
            level += (skill.level - startingLevel);
        }
    }

    return level;
}

const SkillManager = {
    init() {
        // Get hero info from DOM
        const heroCard = document.querySelector('[data-hero-faction]');
        heroBuild.heroFaction = heroCard?.dataset.heroFaction || '';
        heroBuild.heroId = heroCard?.dataset.heroId || '';
        heroBuild.heroViewRadius = parseInt(heroCard?.dataset.heroViewRadius || '6', 10);
        heroBuild.baseHeroLevel = parseInt(heroCard?.dataset.heroLevel || '1', 10);
        heroBuild.heroSpecialization = heroCard?.dataset.heroSpec ? JSON.parse(heroCard.dataset.heroSpec) : null;

        // Initialize skills array with 8 slots
        heroBuild.skills = new Array(8).fill(null);
        heroBuild.startingSkillLevels = {};

        // Get starting skills from DOM
        const skillSlots = document.querySelectorAll('.skill-with-subs');
        skillSlots.forEach((slot, index) => {
            const skillMain = slot.querySelector('.skill-main');
            const skillId = skillMain?.dataset.skillId;
            const skillLevel = parseInt(skillMain?.dataset.skillLevel) || 1;

            if (skillId) {
                // Extract name from tooltip if present
                const tooltipName = skillMain.querySelector('.tooltip-name')?.textContent || skillId;
                const tooltipDescEl = skillMain.querySelector('.tooltip-desc');

                // Extract description pipeline fields from data attributes
                const descTemplate = tooltipDescEl?.dataset.skillTemplate || '';
                const descArgs = tooltipDescEl?.dataset.skillArgs ? JSON.parse(tooltipDescEl.dataset.skillArgs) : [];
                const rawData = tooltipDescEl?.dataset.skillRaw ? JSON.parse(tooltipDescEl.dataset.skillRaw) : null;

                // Remove level prefix from name if it exists
                const name = tooltipName.replace(/^(Basic|Advanced|Expert)\s+/, '');

                heroBuild.skills[index] = {
                    skillId: skillId,
                    level: skillLevel,
                    subskills: [null, null],
                    subskillNames: [null, null],
                    subskillDescs: [null, null],
                    subskillRawData: [null, null],
                    name: name,
                    description: '', // Will be computed dynamically
                    description_template: descTemplate,
                    description_args: descArgs,
                    raw_data: rawData
                };
                heroBuild.startingSkillIds.push(skillId);
                heroBuild.startingSkillLevels[skillId] = skillLevel;  // Track starting level
            }
        });

        // Fetch full skill data and enrich starting skills with template/args/raw_data
        fetch(`/api/skills/available/?hero_slug=${heroBuild.heroId}`)
            .then(response => response.json())
            .then(data => {
                const skillsMap = {};
                data.skills.forEach(s => { skillsMap[s.id] = s; });

                // Enrich starting skills with full data for dynamic descriptions
                heroBuild.skills.forEach((skill, index) => {
                    if (skill && skillsMap[skill.skillId]) {
                        const fullData = skillsMap[skill.skillId];
                        skill.description_template = fullData.description_template || '';
                        skill.description_args = fullData.description_args || [];
                        skill.raw_data = fullData.raw_data || null;
                    }
                });

                // Re-render UI now that skills have full data
                this.updateUI();
            })
            .catch(err => console.warn('Could not enrich starting skills:', err));

        // Set up all click handlers (including subskill buttons for starting skills)
        this.updateUI();
    },

    setupClickHandlers() {
        const skillSlots = document.querySelectorAll('.skill-with-subs');
        skillSlots.forEach((slot, index) => {
            const skillMain = slot.querySelector('.skill-main');

            // Check if it's an empty slot
            if (heroBuild.skills[index] === null) {
                skillMain.style.cursor = 'pointer';
                skillMain.onclick = () => SkillSelectionModal.open(index);
            }
        });
    },

    addSkill(slotIndex, skillData) {
        heroBuild.skills[slotIndex] = {
            skillId: skillData.id,
            level: 1,
            subskills: [null, null],
            subskillNames: [null, null],
            subskillDescs: [null, null],
            subskillRawData: [null, null],
            name: skillData.name,
            icon: skillData.icon,
            description: skillData.description || '',
            description_template: skillData.description_template || '',
            description_args: skillData.description_args || [],
            raw_data: skillData.raw_data || null
        };
        this.updateUI();
        // Update all descriptions since skill bonuses may affect them
        EquipmentManager.updateAllDescriptions();
    },

    getSelectedSkillIds() {
        return heroBuild.skills
            .filter(s => s !== null)
            .map(s => s.skillId);
    },

    levelUpSkill(slotIndex, subskillId, subskillName, subskillDesc, subskillRawData) {
        const skill = heroBuild.skills[slotIndex];
        if (!skill || skill.level >= 3) return;

        // Store subskill at the appropriate index (0 for Basic→Advanced, 1 for Advanced→Expert)
        const subskillIndex = skill.level - 1;
        skill.subskills[subskillIndex] = subskillId;
        skill.subskillNames[subskillIndex] = subskillName;
        skill.subskillDescs[subskillIndex] = subskillDesc || '';
        skill.subskillRawData[subskillIndex] = subskillRawData || null;

        // Increase level
        skill.level++;

        // Update UI and descriptions (skill level affects bonuses)
        this.updateUI();
        EquipmentManager.updateAllDescriptions();
    },

    repickSubskill(slotIndex, subskillSlot, subskillId, subskillName, subskillDesc, subskillRawData) {
        const skill = heroBuild.skills[slotIndex];
        if (!skill) return;

        // Replace the subskill at the specified slot (no level change)
        skill.subskills[subskillSlot] = subskillId;
        skill.subskillNames[subskillSlot] = subskillName;
        skill.subskillDescs[subskillSlot] = subskillDesc || '';
        skill.subskillRawData[subskillSlot] = subskillRawData || null;

        // Update UI and descriptions (subskill bonuses may affect item descriptions)
        this.updateUI();
        EquipmentManager.updateAllDescriptions();
    },

    removeSkill(slotIndex) {
        const skill = heroBuild.skills[slotIndex];
        if (!skill) return;

        // Can't remove starting skills
        if (heroBuild.startingSkillIds.includes(skill.skillId)) {
            alert('Cannot remove starting skills');
            return;
        }

        // Reset slot
        heroBuild.skills[slotIndex] = null;
        this.updateUI();
        // Update descriptions since skill bonuses are removed
        EquipmentManager.updateAllDescriptions();
    },

    updateUI() {
        const skillSlots = document.querySelectorAll('.skill-with-subs');

        heroBuild.skills.forEach((skill, index) => {
            if (index >= skillSlots.length) return;

            const slot = skillSlots[index];
            const skillMain = slot.querySelector('.skill-main');
            const subskillBtns = slot.querySelectorAll('.subskill-btn');

            if (skill === null) {
                // Empty slot - show plus sign
                skillMain.innerHTML = '<span class="skill-add-text">+</span>';
                skillMain.style.cursor = 'pointer';
                skillMain.onclick = () => SkillSelectionModal.open(index);
                skillMain.oncontextmenu = null;
                skillMain.removeAttribute('data-skill-id');

                // Disable both subskill buttons
                subskillBtns.forEach(btn => {
                    btn.className = 'subskill-btn disabled';
                    btn.innerHTML = '';
                    btn.onclick = null;
                });
            } else {
                // Filled slot - show skill icon with tooltip
                const iconSuffix = skill.level > 1 ? `_${skill.level}` : '';
                const levelPrefix = skill.level === 1 ? 'Basic ' : skill.level === 2 ? 'Advanced ' : 'Expert ';

                skillMain.className = 'skill-main tooltip-wrapper';
                skillMain.innerHTML = `
                    <img src="/media/gamedata/skills/${skill.skillId}${iconSuffix}.png" alt="${skill.name || skill.skillId}">
                    ${typeof AdvancedClassManager !== 'undefined' ? AdvancedClassManager.renderSkillIndicators(skill.skillId) : ''}
                    <div class="tooltip-content">
                        <div class="tooltip-name">${levelPrefix}${skill.name || skill.skillId}</div>
                        ${(() => { const desc = EquipmentManager.formatSkillDescription(skill, skill.level); return desc ? `<div class="tooltip-desc">${desc}</div>` : ''; })()}
                    </div>
                `;
                skillMain.dataset.skillId = skill.skillId;
                skillMain.dataset.skillLevel = skill.level;

                // Add right-click to remove (only for non-starting skills)
                if (!heroBuild.startingSkillIds.includes(skill.skillId)) {
                    skillMain.oncontextmenu = (e) => {
                        e.preventDefault();
                        if (confirm(`Remove ${skill.name || skill.skillId}?`)) {
                            SkillManager.removeSkill(index);
                        }
                    };
                } else {
                    skillMain.oncontextmenu = null;
                }

                // First subskill button
                if (skill.level === 1) {
                    // Can level up to Advanced
                    subskillBtns[0].className = 'subskill-btn';
                    subskillBtns[0].innerHTML = '<span class="add-text">+</span>';
                    subskillBtns[0].onclick = () => SubskillSelectionModal.open(index);
                } else if (!skill.subskills[0]) {
                    // Level 2+ but no first subskill yet (e.g., Lord Edgar starts at Advanced)
                    // Allow selecting first subskill without leveling up
                    subskillBtns[0].className = 'subskill-btn';
                    subskillBtns[0].innerHTML = '<span class="add-text">+</span>';
                    subskillBtns[0].onclick = () => SubskillSelectionModal.openForRepick(index, 0);
                } else {
                    // Show selected subskill with tooltip - clickable to repick
                    subskillBtns[0].className = 'subskill-btn filled tooltip-wrapper';
                    subskillBtns[0].innerHTML = `
                        <img src="/media/gamedata/skills/${skill.subskills[0]}_icon.png">
                        <div class="tooltip-content">
                            <div class="tooltip-name">${skill.subskillNames[0] || skill.subskills[0]}</div>
                            ${skill.subskillDescs[0] ? `<div class="tooltip-desc">${skill.subskillDescs[0]}</div>` : ''}
                        </div>
                    `;
                    subskillBtns[0].style.cursor = 'pointer';
                    subskillBtns[0].onclick = () => SubskillSelectionModal.openForRepick(index, 0);
                }

                // Second subskill button
                if (skill.level < 2) {
                    // Skill is Basic - second subskill not available
                    subskillBtns[1].className = 'subskill-btn disabled';
                    subskillBtns[1].innerHTML = '';
                    subskillBtns[1].onclick = null;
                } else if (skill.level === 2 && skill.subskills[0]) {
                    // Advanced with first subskill - can level up to Expert
                    subskillBtns[1].className = 'subskill-btn';
                    subskillBtns[1].innerHTML = '<span class="add-text">+</span>';
                    subskillBtns[1].onclick = () => SubskillSelectionModal.open(index);
                } else if (skill.level === 2 && !skill.subskills[0]) {
                    // Advanced but no first subskill - must pick first subskill first
                    subskillBtns[1].className = 'subskill-btn disabled';
                    subskillBtns[1].innerHTML = '';
                    subskillBtns[1].onclick = null;
                } else if (skill.level === 3 && !skill.subskills[1]) {
                    // Expert but no second subskill yet - allow selecting without level change
                    subskillBtns[1].className = 'subskill-btn';
                    subskillBtns[1].innerHTML = '<span class="add-text">+</span>';
                    subskillBtns[1].onclick = () => SubskillSelectionModal.openForRepick(index, 1);
                } else if (skill.subskills[1]) {
                    // Show selected subskill with tooltip - clickable to repick
                    subskillBtns[1].className = 'subskill-btn filled tooltip-wrapper';
                    subskillBtns[1].innerHTML = `
                        <img src="/media/gamedata/skills/${skill.subskills[1]}_icon.png">
                        <div class="tooltip-content">
                            <div class="tooltip-name">${skill.subskillNames[1] || skill.subskills[1]}</div>
                            ${skill.subskillDescs[1] ? `<div class="tooltip-desc">${skill.subskillDescs[1]}</div>` : ''}
                        </div>
                    `;
                    subskillBtns[1].style.cursor = 'pointer';
                    subskillBtns[1].onclick = () => SubskillSelectionModal.openForRepick(index, 1);
                }
            }
        });

        // Update advanced class progress tooltip
        if (typeof AdvancedClassManager !== 'undefined') {
            AdvancedClassManager.updateTooltip();
        }
    }
};

// Skill Selection Modal with API integration
const SkillSelectionModal = {
    allSkills: [],
    slotIndex: null,

    async open(slotIndex) {
        this.slotIndex = slotIndex;

        // Get faction from hero card data attribute
        const heroFaction = document.querySelector('[data-hero-faction]')?.dataset.heroFaction || '';
        const excludeIds = SkillManager.getSelectedSkillIds().join(',');

        // Fetch skills from API
        try {
            const response = await fetch(`/api/skills/available/?faction=${heroFaction}&exclude=${excludeIds}`);
            const data = await response.json();
            // Cache descriptions for search (computed once for performance)
            this.allSkills = (data.skills || []).map(skill => {
                // Compute description using transpiled pipeline if available
                const computedDesc = EquipmentManager.formatSkillDescription(skill, 1);
                return {
                    ...skill,
                    _computedDescription: computedDesc,
                    _cachedDescription: (computedDesc || skill.description || '').toLowerCase()
                };
            });
            this.render(this.allSkills);
        } catch (error) {
            console.error('Error fetching skills:', error);
            // Show error state
            const container = document.getElementById('skill-modal-container');
            container.innerHTML = `
                <div class="modal-overlay" onclick="SkillSelectionModal.close()">
                    <div class="skill-modal" onclick="event.stopPropagation()">
                        <div class="modal-header">
                            <h2>Select Skill</h2>
                            <p style="color: #ff6666;">Error loading skills. Please try again.</p>
                        </div>
                    </div>
                </div>
            `;
        }
    },

    render(skills) {
        const container = document.getElementById('skill-modal-container');
        container.innerHTML = `
            <div class="modal-overlay" onclick="SkillSelectionModal.close()">
                <div class="skill-modal" onclick="event.stopPropagation()">
                    <div class="modal-header">
                        <h2>Select Skill</h2>
                        <input type="text"
                               class="skill-search"
                               placeholder="Search skills..."
                               oninput="SkillSelectionModal.filter(this.value)">
                    </div>
                    <div class="skill-list" id="skill-list">
                        ${skills.map(s => this.renderSkillOption(s)).join('')}
                    </div>
                </div>
            </div>
        `;
    },

    renderSkillOption(skill) {
        // Use computed description (from transpiled pipeline) or fallback to pre-computed
        const displayDescription = skill._computedDescription || skill.description;
        return `
            <div class="skill-option" data-skill-id="${skill.id}"
                 onclick="SkillSelectionModal.select('${skill.id}')">
                <div class="skill-icon-wrapper">
                    <img src="/media/gamedata/skills/${skill.icon}.png" class="skill-icon" alt="${skill.name}">
                    ${typeof AdvancedClassManager !== 'undefined' ? AdvancedClassManager.renderSkillIndicators(skill.id) : ''}
                </div>
                <div class="skill-info">
                    <div class="skill-name">BASIC ${skill.name.toUpperCase()}</div>
                    <div class="skill-desc">${displayDescription}</div>
                </div>
                <div class="subskill-previews">
                    ${(skill.subskill_preview || []).map(sub =>
                        `<div class="subskill-preview-wrapper tooltip-wrapper">
                            <img src="/media/gamedata/skills/${sub.icon}.png" class="subskill-preview-icon" alt="${sub.name}">
                            <div class="tooltip-content">
                                <div class="tooltip-name">${sub.name}</div>
                                <div class="tooltip-desc">${sub.description}</div>
                            </div>
                        </div>`
                    ).join('')}
                </div>
            </div>
        `;
    },

    filter(searchText) {
        const search = searchText.toLowerCase();
        const filtered = this.allSkills.filter(s =>
            s.name.toLowerCase().includes(search) ||
            (s._cachedDescription && s._cachedDescription.includes(search))
        );
        document.getElementById('skill-list').innerHTML =
            filtered.map(s => this.renderSkillOption(s)).join('');
    },

    select(skillId) {
        const skill = this.allSkills.find(s => s.id === skillId);
        if (skill) {
            SkillManager.addSkill(this.slotIndex, skill);
        }
        this.close();
    },

    close() {
        document.getElementById('skill-modal-container').innerHTML = '';
    }
};

const SubskillSelectionModal = {
    slotIndex: null,
    subskillSlot: null,  // 0 or 1, for repicking
    isRepick: false,
    currentSubskills: [],  // Store fetched subskills for raw_data access

    async open(slotIndex) {
        this.slotIndex = slotIndex;
        this.subskillSlot = null;
        this.isRepick = false;
        const skill = heroBuild.skills[slotIndex];
        if (!skill) return;

        const nextLevel = skill.level + 1;
        if (nextLevel > 3) return;  // Already at max level

        try {
            const response = await fetch(`/api/skills/${skill.skillId}/level/${nextLevel}/subskills/`);
            if (!response.ok) throw new Error('Failed to fetch subskills');
            const data = await response.json();
            this.render(data);
        } catch (error) {
            console.error('Error loading subskills:', error);
        }
    },

    async openForRepick(slotIndex, subskillSlot) {
        this.slotIndex = slotIndex;
        this.subskillSlot = subskillSlot;
        this.isRepick = true;
        const skill = heroBuild.skills[slotIndex];
        if (!skill) return;

        // subskillSlot 0 = level 2 subskills, subskillSlot 1 = level 3 subskills
        const level = subskillSlot + 2;

        try {
            const response = await fetch(`/api/skills/${skill.skillId}/level/${level}/subskills/`);
            if (!response.ok) throw new Error('Failed to fetch subskills');
            const data = await response.json();
            this.render(data);
        } catch (error) {
            console.error('Error loading subskills:', error);
        }
    },

    render(data) {
        // Store subskills for raw_data access in select()
        this.currentSubskills = data.subskills;

        // Get the skill from heroBuild to use its template/args for dynamic formatting
        const skill = heroBuild.skills[this.slotIndex];
        // Compute description dynamically at the new level
        const skillDesc = skill ?
            EquipmentManager.formatSkillDescription(skill, data.skill.level) :
            data.skill.description;

        const container = document.getElementById('skill-modal-container');
        container.innerHTML = `
            <div class="modal-overlay" onclick="SubskillSelectionModal.close()">
                <div class="subskill-modal" onclick="event.stopPropagation()">
                    <div class="upgraded-skill">
                        <img src="/media/gamedata/skills/${data.skill.icon}.png" class="skill-icon-large">
                        <div class="skill-info">
                            <div class="skill-name">${data.skill.name.toUpperCase()}</div>
                            <div class="skill-desc">${skillDesc}</div>
                        </div>
                    </div>
                    <div class="subskill-options">
                        ${data.subskills.map(sub => this.renderSubskillOption(sub)).join('')}
                    </div>
                </div>
            </div>
        `;
    },

    renderSubskillOption(subskill) {
        // Compute description dynamically using the Entity Description Pipeline
        const subskillDesc = EquipmentManager.formatSubskillDescription(subskill);

        return `
            <div class="subskill-option" onclick="SubskillSelectionModal.select('${subskill.id}')">
                <img src="/media/gamedata/skills/${subskill.icon}.png" class="subskill-icon">
                <div class="subskill-info">
                    <div class="subskill-name">${subskill.name}</div>
                    <div class="subskill-desc">${subskillDesc}</div>
                </div>
            </div>
        `;
    },

    select(subskillId) {
        // Find the full subskill data from stored subskills
        const subskill = this.currentSubskills.find(s => s.id === subskillId);
        const subskillName = subskill?.name || subskillId;
        const subskillDesc = subskill ? EquipmentManager.formatSubskillDescription(subskill) : '';
        const subskillRawData = subskill?.raw_data || null;

        if (this.isRepick) {
            SkillManager.repickSubskill(this.slotIndex, this.subskillSlot, subskillId, subskillName, subskillDesc, subskillRawData);
        } else {
            SkillManager.levelUpSkill(this.slotIndex, subskillId, subskillName, subskillDesc, subskillRawData);
        }
        this.close();
    },

    close() {
        document.getElementById('skill-modal-container').innerHTML = '';
    }
};

const ItemSelectionModal = {
    allItems: [],
    currentSlot: null,
    currentSlotType: null,
    showScrolls: false,  // Hide scrolls by default in accessory slot

    // Map UI slot types (from data-slot-type) to API slot types
    slotTypeMap: {
        'unique': 'unique',
        'head': 'head',
        'back': 'back',
        'armor': 'armor',
        'weapon': 'weapon',
        'shield': 'shield',
        'belt': 'belt',
        'boots': 'boots',
        'ring': 'ring',
        'accessory': 'accessory'
    },

    // Rarity colors
    rarityColors: {
        'common': '#ffffff',
        'uncommon': '#1eff00',
        'rare': '#0070dd',
        'epic': '#a335ee',
        'legendary': '#ff8000',
        'relic': '#e6cc80'
    },

    async open(slotId, slotType) {
        this.currentSlot = slotId;
        this.currentSlotType = slotType;

        // Map UI slot type to API slot type
        const apiSlotType = this.slotTypeMap[slotType] || slotType;

        // Fetch items from API
        try {
            const response = await fetch(`/api/items/available/?slot=${apiSlotType}`);
            if (!response.ok) throw new Error('Failed to fetch items');
            const data = await response.json();
            // Cache descriptions and set names for search (computed once for performance)
            this.allItems = (data.items || []).map(item => {
                const setData = item.item_set ? ItemSetManager.getSetForItem(item.id) : null;
                return {
                    ...item,
                    _cachedDescription: (EquipmentManager.formatItemDescription(item) || '').toLowerCase(),
                    _cachedSetName: setData ? setData.name.toLowerCase() : ''
                };
            });
            this.render();
        } catch (error) {
            console.error('Error fetching items:', error);
            // Show error state
            const container = document.getElementById('skill-modal-container');
            container.innerHTML = `
                <div class="modal-overlay" onclick="ItemSelectionModal.close()">
                    <div class="skill-modal" onclick="event.stopPropagation()">
                        <div class="modal-header">
                            <h2>Select Item</h2>
                            <p style="color: #ff6666;">Error loading items. Please try again.</p>
                        </div>
                    </div>
                </div>
            `;
        }
    },

    // Check if an item is a scroll
    isScroll(item) {
        return item.id && item.id.toLowerCase().includes('scroll');
    },

    // Rarity sort order (lower = higher priority)
    rarityOrder: {
        'legendary': 0,
        'epic': 1,
        'rare': 2,
        'uncommon': 3,
        'common': 4
    },

    // Get filtered items based on search and scroll toggle, sorted by rarity
    getFilteredItems(searchText = '') {
        const search = searchText.toLowerCase();
        const filtered = this.allItems.filter(item => {
            // Filter by scroll toggle (only for accessory slot)
            if (this.currentSlotType === 'accessory' && !this.showScrolls && this.isScroll(item)) {
                return false;
            }
            // Filter by search text (name, description, or set name)
            if (search) {
                return item.name.toLowerCase().includes(search) ||
                       (item._cachedDescription && item._cachedDescription.includes(search)) ||
                       (item._cachedSetName && item._cachedSetName.includes(search));
            }
            return true;
        });

        // Sort by rarity: Legendary > Epic > Rare > Uncommon > Common
        return filtered.sort((a, b) => {
            const orderA = this.rarityOrder[a.rarity] ?? 99;
            const orderB = this.rarityOrder[b.rarity] ?? 99;
            return orderA - orderB;
        });
    },

    toggleScrolls() {
        this.showScrolls = !this.showScrolls;
        // Re-render with current search text
        const searchInput = document.querySelector('.skill-search');
        const searchText = searchInput ? searchInput.value : '';
        this.updateItemList(searchText);
        // Update checkbox state
        const checkbox = document.getElementById('show-scrolls-toggle');
        if (checkbox) checkbox.checked = this.showScrolls;
    },

    updateItemList(searchText = '') {
        const filtered = this.getFilteredItems(searchText);
        document.getElementById('item-list').innerHTML =
            filtered.map(item => this.renderItemOption(item)).join('');
    },

    render() {
        const container = document.getElementById('skill-modal-container');
        const isAccessory = this.currentSlotType === 'accessory';
        const scrollToggleHtml = isAccessory ? `
            <label class="scroll-toggle">
                <input type="checkbox" id="show-scrolls-toggle"
                       ${this.showScrolls ? 'checked' : ''}
                       onchange="ItemSelectionModal.toggleScrolls()">
                Show scrolls
            </label>
        ` : '';

        container.innerHTML = `
            <div class="modal-overlay" onclick="ItemSelectionModal.close()">
                <div class="skill-modal" onclick="event.stopPropagation()">
                    <div class="modal-header">
                        <h2>Select Item - ${this.currentSlotType}</h2>
                        <div class="modal-controls">
                            <input type="text"
                                   class="skill-search"
                                   placeholder="Search items..."
                                   oninput="ItemSelectionModal.filter(this.value)">
                            ${scrollToggleHtml}
                        </div>
                    </div>
                    <div class="skill-list" id="item-list">
                        ${this.getFilteredItems().map(item => this.renderItemOption(item)).join('')}
                    </div>
                </div>
            </div>
        `;
    },

    renderItemOption(item) {
        const rarityColor = this.rarityColors[item.rarity] || '#ffffff';
        // Always calculate description dynamically using EquipmentManager
        const displayText = EquipmentManager.formatItemDescription(item) ||
                           (item.bonuses || []).join(', ') ||
                           'No description';

        // Check if item belongs to a set
        let setHTML = '';
        if (item.item_set) {
            const setData = ItemSetManager.getSetForItem(item.id);
            if (setData) {
                const equippedCount = ItemSetManager.getEquippedSetItemCount(item.item_set);
                const totalItems = setData.items.length;
                setHTML = `
                    <div class="item-set-badge" title="${setData.name}">
                        <span class="set-name">${setData.name}</span>
                        <span class="set-count">(${equippedCount}/${totalItems})</span>
                    </div>
                `;
            }
        }

        return `
            <div class="skill-option" data-item-id="${item.id}"
                 onclick="ItemSelectionModal.select('${item.id}')">
                <div class="skill-icon-wrapper">
                    <img src="/media/gamedata/items/${item.icon}.png" class="skill-icon" alt="${item.name}">
                </div>
                <div class="skill-info">
                    <div class="skill-name-row">
                        <span class="skill-name" style="color: ${rarityColor};">${item.name.toUpperCase()}</span>
                        ${setHTML}
                    </div>
                    <div class="skill-desc" style="color: ${rarityColor}; opacity: 0.7; font-size: 0.8rem; margin-bottom: 5px;">
                        ${item.rarity.charAt(0).toUpperCase() + item.rarity.slice(1)}
                    </div>
                    <div class="skill-desc">${displayText}</div>
                </div>
            </div>
        `;
    },

    filter(searchText) {
        this.updateItemList(searchText);
    },

    select(itemId) {
        const item = this.allItems.find(i => i.id === itemId);
        if (item) {
            // Use EquipmentManager to equip the item
            EquipmentManager.equipItem(this.currentSlot, item);
        }
        this.close();
    },

    close() {
        document.getElementById('skill-modal-container').innerHTML = '';
    }
};

const AdvancedClassManager = {
    advancedClasses: [],  // Cached from API
    skillIndicators: {},  // Cached skill -> class mapping
    baseClassName: '',     // Base class name like "Cleric"
    baseClassDescription: '', // Base class description
    baseClassIconUrl: '',  // Original class badge icon URL

    async init() {
        // Get hero faction and class_type from DOM
        const heroCard = document.querySelector('[data-hero-faction]');
        const heroFaction = heroCard?.dataset.heroFaction || '';
        const heroClassType = heroCard?.dataset.heroClassType || '';

        if (!heroFaction || !heroClassType) return;

        // Fetch advanced classes (includes base class info)
        try {
            const response = await fetch(`/api/advanced-classes/?faction=${heroFaction}&class_type=${heroClassType}`);
            const data = await response.json();
            this.advancedClasses = data.advanced_classes || [];
            this.baseClassName = data.base_class_name || heroClassType;
            this.baseClassDescription = data.base_class_description || '';
            this.baseClassIconUrl = data.base_class_icon_url || '';
        } catch (e) {
            console.error('Error fetching advanced classes:', e);
        }

        // Fetch skill indicators
        try {
            const indicatorResponse = await fetch(`/api/advanced-classes/skill-indicators/?faction=${heroFaction}&class_type=${heroClassType}`);
            const indicatorData = await indicatorResponse.json();
            this.skillIndicators = indicatorData.skill_indicators || {};
        } catch (e) {
            console.error('Error fetching skill indicators:', e);
        }

        // Setup tooltip
        this.setupClassBadgeTooltip();

        // Refresh skill UI to add indicators to starting skills
        SkillManager.updateUI();
    },

    getSkillIndicators(skillId) {
        return this.skillIndicators[skillId] || [];
    },

    renderSkillIndicators(skillId) {
        const indicators = this.getSkillIndicators(skillId);
        if (indicators.length === 0) return '';

        return `<div class="skill-indicators">
            ${indicators.map(ind => `<img src="${ind.icon_url}" class="skill-indicator-icon" alt="${ind.class_id}">`).join('')}
        </div>`;
    },

    setupClassBadgeTooltip() {
        const wrapper = document.querySelector('.class-badge-wrapper');
        if (!wrapper) return;

        // Create tooltip content
        this.updateTooltip();
    },

    updateTooltip() {
        const wrapper = document.querySelector('.class-badge-wrapper');
        if (!wrapper) return;

        // Remove existing tooltip
        const existing = wrapper.querySelector('.class-tooltip');
        if (existing) existing.remove();

        // Build tooltip HTML
        const tooltip = document.createElement('div');
        tooltip.className = 'class-tooltip';
        tooltip.innerHTML = this.renderTooltipContent();
        wrapper.appendChild(tooltip);

        // Also update the class badge icon if needed
        this.updateClassBadge();
    },

    renderTooltipContent() {
        // Get specialization data from DOM
        const wrapper = document.querySelector('.class-badge-wrapper');
        const specName = wrapper?.dataset.specName || '';
        const specTemplate = wrapper?.dataset.specTemplate || '';
        const specArgs = JSON.parse(wrapper?.dataset.specArgs || '[]');
        const specRaw = JSON.parse(wrapper?.dataset.specRaw || '{}');

        // Format specialization description using the entity description pipeline
        // Pass the raw specialization data as currentSpecialization context
        let specDesc = specTemplate;
        if (specArgs.length > 0 && typeof DescriptionRuntime !== 'undefined') {
            const ctx = { currentSpecialization: specRaw };
            specDesc = DescriptionRuntime.formatDescription(specTemplate, specArgs, ctx);
        }

        let html = `
            <div class="class-tooltip-header">
                <div class="class-tooltip-name">${specName}</div>
                <div class="class-tooltip-desc">${specDesc}</div>
            </div>
        `;

        // Advanced classes
        if (this.advancedClasses.length > 0) {
            html += '<div class="class-tooltip-divider"></div>';

            for (const advClass of this.advancedClasses) {
                const progress = this.calculateProgress(advClass);
                // Format advanced class description using the entity description pipeline
                let advDesc = advClass.description;
                if (advClass.description_args?.length > 0 && typeof DescriptionRuntime !== 'undefined') {
                    advDesc = DescriptionRuntime.formatDescription(advClass.description_template || advClass.description, advClass.description_args, {});
                }
                html += `
                    <div class="advanced-class-section">
                        <div class="advanced-class-header">
                            <img src="${advClass.icon_url}" class="advanced-class-icon" alt="${advClass.name}">
                            <span class="advanced-class-name">${advClass.name}</span>
                            <span class="advanced-class-progress">${progress}/5</span>
                        </div>
                        <div class="advanced-class-progress-bar">
                            <div class="progress-fill" style="width: ${progress * 20}%"></div>
                        </div>
                        <div class="advanced-class-desc">${advDesc}</div>
                    </div>
                `;
            }
        }

        return html;
    },

    calculateProgress(advClass) {
        // For now return 0, will be implemented in Slice 4
        let count = 0;
        for (const condition of advClass.activation_conditions) {
            const skillId = condition.skillSid;
            const requiredLevel = condition.skillLevel;

            // Check if hero has this skill at required level
            const heroSkill = heroBuild.skills.find(s => s && s.skillId === skillId);
            if (heroSkill && heroSkill.level >= requiredLevel) {
                count++;
            }
        }
        return count;
    },

    checkEligibility() {
        // Find first advanced class with 5/5 progress
        for (const advClass of this.advancedClasses) {
            if (this.calculateProgress(advClass) >= 5) {
                return advClass;
            }
        }
        return null;
    },

    updateClassBadge() {
        const classBadge = document.querySelector('.class-badge');
        if (!classBadge) return;

        const achievedClass = this.checkEligibility();

        if (achievedClass) {
            // Update badge to advanced class icon
            classBadge.src = achievedClass.icon_url;
        } else {
            // Revert to base class icon
            classBadge.src = this.baseClassIconUrl;
        }
    }
};

// Equipment Manager
const EquipmentManager = {
    /**
     * Calculate bonuses for an item at a specific level
     * @param {Array} bonuses_raw - Raw bonus data with base, increment, levelStep
     * @param {number} level - Current upgrade level (0-based)
     * @returns {Array} Array of formatted bonus strings
     */
    // Friendly names for boolean stats
    BOOLEAN_STAT_NAMES: {
        'enableSquadReactionType': 'Shows Unit Initiative',
        'enableSquadCounts': 'Shows Unit Stack Counts',
        'enableEnemyHeroInfo': 'Shows Enemy Hero Info',
        'enableEnemyCityInfo': 'Shows Enemy City Info',
        'enableBansEvasion': 'Can Evade Bans',
        'enableBansEvasionBattle': 'Can Evade Bans in Battle',
        'enableSaveHeroByKill': 'Hero Survives Defeat',
        'enableSavePartyByEscape': 'Party Can Escape',
    },

    // Friendly names for complex stats
    STAT_DISPLAY_NAMES: {
        'finalHealingBonusPercent': 'Healing',
        'finalAbilityDamageBonusPercent': 'Ability Damage',
        'finalSummonBonusPercent': 'Summoning',
        'diplomacyEfficiencyPerBonus': 'Diplomacy',
        'landscapePenaltyPerBonus': 'Terrain Penalty',
        'flyMotionPerBonus': 'Flying Speed',
        'hp': 'HP',
        'offence': 'Offence',
        'defence': 'Defence',
    },

    // Convert camelCase to Title Case
    _camelToTitle(text) {
        const spaced = text.replace(/([A-Z])/g, ' $1');
        return spaced.trim().split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()).join(' ');
    },

    // Calculate bonus value with upgrade scaling
    _calculateBonusValue(baseValue, upgrade, level) {
        if (upgrade && level > 0) {
            const increment = upgrade.increment || 0;
            const levelStep = upgrade.levelStep || 1;
            if (levelStep > 0) {
                return baseValue + (increment * Math.floor(level / levelStep));
            }
        }
        return baseValue;
    },

    calculateBonusesForLevel(bonuses_raw, level) {
        if (!bonuses_raw || bonuses_raw.length === 0) {
            return ['No bonuses'];
        }

        const results = [];
        for (const bonus of bonuses_raw) {
            // If bonus is already a formatted string, use it as-is
            if (typeof bonus === 'string') {
                results.push(bonus);
                continue;
            }

            const bonusType = bonus.type;
            const parameters = bonus.parameters || [];
            const upgrade = bonus.upgrade || {};

            // Check activation level (level is 0-based, activationLevel is 1-based)
            const activationLevel = bonus.activationLevel || 1;
            if ((level + 1) < activationLevel) continue;

            if (bonusType === 'heroStat') {
                if (parameters.length < 2) continue;

                const statName = parameters[0];

                // Special handling for magicSchoolSet: [statName, school, "0", value]
                if (statName === 'magicSchoolSet' && parameters.length >= 4) {
                    const school = parameters[1].charAt(0).toUpperCase() + parameters[1].slice(1);
                    const baseValue = parseFloat(parameters[3]) || 1;
                    const value = Math.round(this._calculateBonusValue(baseValue, upgrade, level));
                    const sign = value >= 0 ? '+' : '';
                    results.push(`${sign}${value} ${school} Magic`);
                    continue;
                }

                const baseValueStr = parameters[1];

                // Handle boolean stats
                if (baseValueStr === 'true' || baseValueStr === 'false' || baseValueStr === true || baseValueStr === false) {
                    if (this.BOOLEAN_STAT_NAMES[statName]) {
                        results.push(this.BOOLEAN_STAT_NAMES[statName]);
                    } else {
                        const displayName = this._camelToTitle(statName.replace('enable', ''));
                        results.push(`Enables ${displayName}`);
                    }
                    continue;
                }

                // Handle numeric stats
                const baseValue = parseFloat(baseValueStr) || 0;
                const value = this._calculateBonusValue(baseValue, upgrade, level);
                const displayName = this.STAT_DISPLAY_NAMES[statName] || this._camelToTitle(statName);

                // Detect percentage stats (includes "Percent", "PerBonus", etc.)
                const isPercent = statName.toLowerCase().includes('percent') || statName.toLowerCase().includes('perbonus');
                const intValue = isPercent && Math.abs(value) < 1 ? Math.round(value * 100) : Math.round(value);
                const sign = intValue >= 0 ? '+' : '';

                if (isPercent) {
                    results.push(`${sign}${intValue}% ${displayName}`);
                } else {
                    results.push(`${sign}${intValue} ${displayName}`);
                }
            } else if (bonusType === 'unitStat') {
                if (parameters.length < 2) continue;
                const statName = parameters[0];
                const baseValue = parseFloat(parameters[1]) || 0;
                const value = this._calculateBonusValue(baseValue, upgrade, level);
                const displayName = this.STAT_DISPLAY_NAMES[statName] || this._camelToTitle(statName);

                const allegiance = bonus.receiverAllegiance || 'ally';
                const prefix = allegiance === 'enemy' ? 'Enemy units: ' : 'Units: ';

                // Detect percentage stats (includes "Percent", "PerBonus", etc.)
                const isPercent = statName.toLowerCase().includes('percent') || statName.toLowerCase().includes('perbonus');
                const intValue = isPercent && Math.abs(value) < 1 ? Math.round(value * 100) : Math.round(value);
                const sign = intValue >= 0 ? '+' : '';

                if (isPercent) {
                    results.push(`${prefix}${sign}${intValue}% ${displayName}`);
                } else {
                    results.push(`${prefix}${sign}${intValue} ${displayName}`);
                }
            } else if (bonusType === 'sideRes') {
                if (parameters.length < 2) continue;
                const resource = parameters[0].charAt(0).toUpperCase() + parameters[0].slice(1);
                const baseValue = parseFloat(parameters[1]) || 0;
                const value = Math.round(this._calculateBonusValue(baseValue, upgrade, level));
                results.push(`+${value} ${resource}/day`);
            } else if (bonusType === 'heroMagicAdditionMass') {
                if (parameters.length >= 3) {
                    const tier = parameters[2];
                    if (tier === 'any' || tier === null) {
                        results.push('Unlocks all spells');
                    } else {
                        results.push(`Unlocks all Tier ${tier} spells`);
                    }
                }
            } else if (bonusType === 'heroMagicAddition') {
                results.push('Grants spell');
            } else if (bonusType === 'battleSubskillBonus') {
                results.push('Grants battle skill');
            } else if (bonusType === 'unitBoolStat') {
                if (parameters.length >= 1) {
                    const statName = this._camelToTitle(parameters[0]);
                    results.push(`Units: ${statName}`);
                }
            } else if (bonusType === 'magicSchoolSet') {
                if (parameters.length >= 2) {
                    const school = parameters[0].charAt(0).toUpperCase() + parameters[0].slice(1);
                    const baseValue = parseInt(parameters[1]) || 1;
                    const value = Math.round(this._calculateBonusValue(baseValue, upgrade, level));
                    const sign = value >= 0 ? '+' : '';
                    results.push(`${sign}${value} ${school} Magic`);
                }
            } else if (bonusType === 'heroAbility') {
                if (parameters.length >= 1) {
                    const abilityName = this._camelToTitle(parameters[0]);
                    results.push(`Grants: ${abilityName}`);
                }
            }
        }

        return results.length > 0 ? results : ['No bonuses'];
    },

    /**
     * Calculate dust cost for upgrading to a specific level
     * @param {Object} itemData - Item data with cost_base and cost_per_level
     * @param {number} level - Target upgrade level (1-based, where 1 = base item)
     * @returns {number} Dust cost
     */
    calculateDustCost(itemData, level) {
        if (!itemData || level <= 1) {
            return 0;
        }

        const costBase = itemData.cost_base || 0;
        const costPerLevel = itemData.cost_per_level || 0;

        return costBase + costPerLevel * (level - 1);
    },

    /**
     * Get total dust cost for all equipped items
     * @returns {number} Total dust cost
     */
    getTotalDustCost() {
        let total = 0;
        for (const itemData of Object.values(heroBuild.equipment.slots)) {
            if (itemData) {
                total += this.calculateDustCost(itemData, itemData.level);
            }
        }
        return total;
    },

    /**
     * Update the dust cost display element
     */
    updateDustDisplay() {
        const displayElement = document.getElementById('total-equipment-dust');
        if (displayElement) {
            const totalDust = this.getTotalDustCost();
            const dustValue = displayElement.querySelector('.dust-value');
            if (dustValue) {
                dustValue.textContent = totalDust;
            }
        }
    },

    /**
     * Get effective hero stats including base stats and all equipment bonuses
     * @returns {Object} Hero stats object e.g., {viewRadius: 8, offence: 5, ...}
     */
    getEffectiveHeroStats() {
        // Start with base hero stats
        const stats = {
            viewRadius: heroBuild.heroViewRadius,
            offence: parseInt(document.querySelector('[data-stat="offence"] .stat-value')?.textContent || '0'),
            defence: parseInt(document.querySelector('[data-stat="defence"] .stat-value')?.textContent || '0'),
            spellPower: parseInt(document.querySelector('[data-stat="spell-power"] .stat-value')?.textContent || '0'),
            intelligence: parseInt(document.querySelector('[data-stat="intelligence"] .stat-value')?.textContent || '0'),
            luck: parseInt(document.querySelector('[data-stat="luck"] .stat-value')?.textContent || '0'),
            moral: parseInt(document.querySelector('[data-stat="moral"] .stat-value')?.textContent || '0'),
        };

        // Add bonuses from all equipped items
        for (const itemData of Object.values(heroBuild.equipment.slots)) {
            const bonuses = itemData?.raw_data?.bonuses;
            if (!bonuses) continue;
            const level = itemData.level || 1;

            for (const bonus of bonuses) {
                if (bonus.type !== 'heroStat') continue;
                const params = bonus.parameters || [];
                if (params.length < 2) continue;

                const statName = params[0];
                const baseValue = parseFloat(params[1]);
                if (isNaN(baseValue)) continue;

                const upgrade = bonus.upgrade || {};
                const value = this._calculateBonusValue(baseValue, upgrade, level - 1);

                // Map game stat names to our stat object keys
                const statMap = {
                    'viewRadius': 'viewRadius',
                    'offence': 'offence',
                    'defence': 'defence',
                    'spellPower': 'spellPower',
                    'intelligence': 'intelligence',
                    'luck': 'luck',
                    'moral': 'moral',
                };
                const key = statMap[statName];
                if (key) {
                    stats[key] = (stats[key] || 0) + value;
                }
            }
        }

        // Add bonuses from equipped skills
        for (const skillData of heroBuild.skills) {
            if (!skillData || !skillData.raw_data) continue;
            const level = skillData.level || 1;
            const levelData = skillData.raw_data.parametersPerLevel?.[level - 1];
            if (!levelData?.bonuses) continue;

            for (const bonus of levelData.bonuses) {
                if (bonus.type !== 'heroStat') continue;
                const params = bonus.parameters || [];
                if (params.length < 2) continue;

                const statName = params[0];
                const value = parseFloat(params[1]);
                if (isNaN(value)) continue;

                // Map game stat names to our stat object keys
                const statMap = {
                    'viewRadius': 'viewRadius',
                    'offence': 'offence',
                    'defence': 'defence',
                    'spellPower': 'spellPower',
                    'intelligence': 'intelligence',
                    'luck': 'luck',
                    'moral': 'moral',
                };
                const key = statMap[statName];
                if (key) {
                    stats[key] = (stats[key] || 0) + value;
                }
            }
        }

        // Add bonuses from subskills
        for (const skillData of heroBuild.skills) {
            if (!skillData) continue;

            for (let i = 0; i < 2; i++) {
                const subskillRawData = skillData.subskillRawData?.[i];
                if (!subskillRawData?.bonuses) continue;

                for (const bonus of subskillRawData.bonuses) {
                    if (bonus.type !== 'heroStat') continue;
                    const params = bonus.parameters || [];
                    if (params.length < 2) continue;

                    const statName = params[0];
                    const value = parseFloat(params[1]);
                    if (isNaN(value)) continue;

                    // Map game stat names to our stat object keys
                    const statMap = {
                        'viewRadius': 'viewRadius',
                        'offence': 'offence',
                        'defence': 'defence',
                        'spellPower': 'spellPower',
                        'intelligence': 'intelligence',
                        'luck': 'luck',
                        'moral': 'moral',
                    };
                    const key = statMap[statName];
                    if (key) {
                        stats[key] = (stats[key] || 0) + value;
                    }
                }
            }
        }

        // Add bonuses from hero specialization
        const spec = heroBuild.heroSpecialization;
        if (spec?.bonuses) {
            const heroLevel = getHeroLevel();
            for (const bonus of spec.bonuses) {
                // Skip bonuses that require a higher activation level
                if (bonus.activationLevel && bonus.activationLevel > heroLevel) continue;

                if (bonus.type !== 'heroStat') continue;
                const params = bonus.parameters || [];
                if (params.length < 2) continue;

                const statName = params[0];
                const baseValue = parseFloat(params[1]);
                if (isNaN(baseValue)) continue;

                // Calculate level-based upgrades (triggers at 5, 10, 15, etc.)
                let value = baseValue;
                const upgrade = bonus.upgrade;
                if (upgrade && upgrade.increment && upgrade.levelStep) {
                    const upgradeCount = Math.floor(heroLevel / upgrade.levelStep);
                    value += upgrade.increment * upgradeCount;
                }

                // Map game stat names to our stat object keys
                const statMap = {
                    'viewRadius': 'viewRadius',
                    'offence': 'offence',
                    'defence': 'defence',
                    'spellPower': 'spellPower',
                    'intelligence': 'intelligence',
                    'luck': 'luck',
                    'moral': 'moral',
                    'morale': 'moral',
                };
                const key = statMap[statName];
                if (key) {
                    stats[key] = (stats[key] || 0) + value;
                }
            }
        }

        // Add bonuses from unlocked advanced class (subclass)
        if (typeof AdvancedClassManager !== 'undefined') {
            const unlockedClass = AdvancedClassManager.checkEligibility();
            if (unlockedClass?.bonuses) {
                for (const bonus of unlockedClass.bonuses) {
                    if (bonus.type !== 'heroStat') continue;
                    const params = bonus.parameters || [];
                    if (params.length < 2) continue;

                    const statName = params[0];
                    const value = parseFloat(params[1]);
                    if (isNaN(value)) continue;

                    // Map game stat names to our stat object keys
                    // Note: percentage stats like 'offencePer' multiply base stat
                    const statMap = {
                        'viewRadius': 'viewRadius',
                        'offence': 'offence',
                        'defence': 'defence',
                        'spellPower': 'spellPower',
                        'intelligence': 'intelligence',
                        'luck': 'luck',
                        'moral': 'moral',
                        'morale': 'moral',
                    };

                    // Handle percentage bonuses (e.g., offencePer, defencePer)
                    if (statName.endsWith('Per')) {
                        const baseStat = statName.slice(0, -3);
                        const key = statMap[baseStat];
                        if (key && stats[key]) {
                            stats[key] = stats[key] * (1 + value);
                        }
                    } else {
                        const key = statMap[statName];
                        if (key) {
                            stats[key] = (stats[key] || 0) + value;
                        }
                    }
                }
            }
        }

        // Add bonuses from active item sets
        if (typeof ItemSetManager !== 'undefined' && ItemSetManager.itemSets.length > 0) {
            const setStatBonuses = ItemSetManager.getActiveSetStatBonuses();
            const statMap = {
                'viewRadius': 'viewRadius',
                'offence': 'offence',
                'defence': 'defence',
                'spellPower': 'spellPower',
                'intelligence': 'intelligence',
                'luck': 'luck',
                'moral': 'moral',
                'morale': 'moral',
            };

            for (const [statName, value] of Object.entries(setStatBonuses)) {
                const key = statMap[statName];
                if (key) {
                    stats[key] = (stats[key] || 0) + value;
                }
            }
        }

        return stats;
    },

    /**
     * Format an item's description using current effective hero stats
     * @param {Object} itemData - Item data with description_template and description_args/description_values
     * @param {number} level - Current upgrade level (1-based)
     * @returns {string} Formatted description
     */
    formatItemDescription(itemData, level = null) {
        if (!itemData.description_template) {
            return itemData.description || '';
        }

        level = level || itemData.level || 1;

        // Try using transpiled functions first (new system)
        if (itemData.description_args && itemData.description_args.length > 0 &&
            typeof DescriptionRuntime !== 'undefined' && typeof DescriptionFunctions !== 'undefined') {
            try {
                const effectiveStats = this.getEffectiveHeroStats();

                // Create context for the transpiled functions
                const ctx = {
                    currentItem: {
                        id: itemData.id,
                        level: level,
                        config: itemData.raw_data || { bonuses: [] }
                    },
                    currentHero: {
                        heroStat: effectiveStats
                    }
                };

                // Use DescriptionRuntime to format
                let result = DescriptionRuntime.formatDescription(
                    itemData.description_template,
                    itemData.description_args,
                    ctx
                );

                // Append upgrade description only if it adds new functionality (no computed args)
                // If upgrade has computed args, those values are already reflected in main description
                if (level > 1 && itemData.upgrade_description_template &&
                    (!itemData.upgrade_description_args || itemData.upgrade_description_args.length === 0)) {
                    result += ' ' + this.formatUpgradeDescription(itemData);
                }

                return result;
            } catch (e) {
                console.warn('[EquipmentManager] Transpiled function error, falling back:', e);
            }
        }

        // Fallback to legacy system using description_values
        if (!itemData.description_values || itemData.description_values.length === 0) {
            return itemData.description || itemData.description_template || '';
        }

        const effectiveStats = this.getEffectiveHeroStats();
        const resolvedValues = [];

        for (const valueInfo of itemData.description_values) {
            if (valueInfo.type === 'static') {
                resolvedValues.push(valueInfo.value);
            } else if (valueInfo.type === 'item_param') {
                const base = valueInfo.base || 0;
                const increment = valueInfo.increment || 0;
                const levelStep = valueInfo.levelStep || 1;
                let value = base;
                if (level > 1 && increment && levelStep > 0) {
                    value = base + increment * Math.floor((level - 1) / levelStep);
                }
                if (valueInfo.isPercent && Math.abs(value) < 1) {
                    value = value * 100;
                }
                resolvedValues.push(String(Math.floor(value)));
            } else if (valueInfo.type === 'hero_stat_multiplier') {
                const stat = valueInfo.stat;
                const multiplier = valueInfo.multiplier || 1;
                const statValue = effectiveStats[stat] || 6; // Default viewRadius = 6
                resolvedValues.push(String(Math.floor(statValue * multiplier)));
            } else {
                resolvedValues.push('?');
            }
        }

        // Replace {0}, {1}, etc. in template
        let result = itemData.description_template;
        for (let i = 0; i < resolvedValues.length; i++) {
            result = result.replace(`{${i}}`, resolvedValues[i]);
        }

        // Append upgrade description only if it adds new functionality (no computed args)
        // If upgrade has computed args, those values are already reflected in main description
        if (level > 1 && itemData.upgrade_description_template &&
            (!itemData.upgrade_description_args || itemData.upgrade_description_args.length === 0)) {
            result += ' ' + this.formatUpgradeDescription(itemData);
        }

        return result;
    },

    /**
     * Format an item's upgrade description.
     * @param {Object} itemData - Item data with upgrade_description_template and upgrade_description_args
     * @returns {string} Formatted upgrade description
     */
    formatUpgradeDescription(itemData) {
        if (!itemData.upgrade_description_template) {
            return itemData.upgrade_description || '';
        }

        // Try using transpiled functions
        if (itemData.upgrade_description_args && itemData.upgrade_description_args.length > 0 &&
            typeof DescriptionRuntime !== 'undefined' && typeof DescriptionFunctions !== 'undefined') {
            try {
                const effectiveStats = this.getEffectiveHeroStats();
                const ctx = {
                    currentItem: {
                        id: itemData.id,
                        level: itemData.level || 1,
                        config: itemData.raw_data || { bonuses: [] }
                    },
                    currentHero: {
                        heroStat: effectiveStats
                    }
                };

                return DescriptionRuntime.formatDescription(
                    itemData.upgrade_description_template,
                    itemData.upgrade_description_args,
                    ctx
                );
            } catch (e) {
                console.warn('[EquipmentManager] Upgrade description error, falling back:', e);
            }
        }

        // Fallback to pre-formatted
        return itemData.upgrade_description || itemData.upgrade_description_template || '';
    },

    /**
     * Format a skill description using the transpiled description pipeline.
     * @param {Object} skillData - Skill data with description_template and description_args
     * @param {number} level - Skill level (1-based, default 1)
     * @returns {string} Formatted description
     */
    formatSkillDescription(skillData, level = 1) {
        // If no args, return template as-is (no placeholders to fill)
        if (!skillData.description_args || skillData.description_args.length === 0) {
            return skillData.description_template || '';
        }

        // Use transpiled functions - no fallback, errors should be visible
        if (typeof DescriptionRuntime === 'undefined' || typeof DescriptionFunctions === 'undefined') {
            console.error('[EquipmentManager] DescriptionRuntime or DescriptionFunctions not loaded');
            return '';
        }

        // Get level-specific parameters from raw_data
        const params = skillData.raw_data?.parametersPerLevel || [];
        const levelData = params[level - 1] || params[0] || {};

        // Create context for the transpiled functions
        // Note: skill functions expect bonuses directly on currentSkill (not in config)
        const ctx = {
            currentSkill: {
                id: skillData.skillId || skillData.id,
                level: level,
                ...levelData  // Spread levelData so bonuses are directly accessible
            },
            currentHero: {
                heroStat: this.getEffectiveHeroStats()
            }
        };

        return DescriptionRuntime.formatDescription(
            skillData.description_template,
            skillData.description_args,
            ctx
        );
    },

    /**
     * Format a subskill description using the transpiled description pipeline.
     * @param {Object} subskillData - Subskill data with description_template and description_args
     * @returns {string} Formatted description
     */
    formatSubskillDescription(subskillData) {
        // If no args, return template as-is (no placeholders to fill)
        if (!subskillData.description_args || subskillData.description_args.length === 0) {
            return subskillData.description_template || '';
        }

        // Use transpiled functions - no fallback, errors should be visible
        if (typeof DescriptionRuntime === 'undefined' || typeof DescriptionFunctions === 'undefined') {
            console.error('[EquipmentManager] DescriptionRuntime or DescriptionFunctions not loaded');
            return '';
        }

        // Create context for the transpiled functions
        // Subskills use currentSubSkill context (not currentSkill)
        const ctx = {
            currentSubSkill: {
                id: subskillData.id,
                ...subskillData.raw_data  // Spread raw_data so bonuses are accessible
            },
            currentHero: {
                heroStat: this.getEffectiveHeroStats()
            }
        };

        return DescriptionRuntime.formatDescription(
            subskillData.description_template,
            subskillData.description_args,
            ctx
        );
    },

    /**
     * Format a spell description using the transpiled description pipeline.
     * @param {Object} spellData - Spell data with description_template and description_args
     * @param {number} level - Spell level (1-based, default 1)
     * @returns {string} Formatted description
     */
    formatSpellDescription(spellData, level = 1) {
        // Prefer computed description if no args
        if (!spellData.description_args || spellData.description_args.length === 0) {
            return spellData.description || spellData.description_template || '';
        }

        // Use transpiled functions
        if (typeof DescriptionRuntime !== 'undefined' && typeof DescriptionFunctions !== 'undefined') {
            try {
                // Create context for the transpiled functions
                const ctx = {
                    currentMagic: {
                        id: spellData.id,
                        level: level,
                        school: spellData.school,
                        config: spellData.raw_data || {}
                    },
                    currentHero: {
                        stats: this.getEffectiveHeroStats()
                    }
                };

                return DescriptionRuntime.formatDescription(
                    spellData.description_template,
                    spellData.description_args,
                    ctx
                );
            } catch (e) {
                console.warn('[EquipmentManager] Spell description error, falling back:', e);
            }
        }

        // Fallback to pre-computed description
        return spellData.description || spellData.description_template || '';
    },

    /**
     * Update all equipped items' descriptions based on current effective stats
     */
    updateAllDescriptions() {
        for (const [slotId, itemData] of Object.entries(heroBuild.equipment.slots)) {
            if (itemData && (
                (itemData.description_args && itemData.description_args.length > 0) ||
                (itemData.description_values && itemData.description_values.length > 0)
            )) {
                itemData.description = this.formatItemDescription(itemData);
            }
        }
        // Re-render equipment UI to show updated descriptions
        this.updateUI();

        // Also update spell descriptions (hero stats may affect spell calculations)
        if (typeof SpellBookManager !== 'undefined') {
            SpellBookManager.updateAllDescriptions();
        }
    },

    maxAllUpgrades() {
        for (const [slotId, itemData] of Object.entries(heroBuild.equipment.slots)) {
            if (itemData && itemData.max_level > 1) {
                itemData.level = itemData.max_level;
                const rawBonuses = itemData.raw_data?.bonuses || [];
                itemData.bonuses = this.calculateBonusesForLevel(rawBonuses, itemData.max_level - 1);
            }
        }
        this.updateAllDescriptions();
        this.updateUI();
        this.updateDustDisplay();
    },

    resetAllUpgrades() {
        for (const [slotId, itemData] of Object.entries(heroBuild.equipment.slots)) {
            if (itemData) {
                itemData.level = 1;
                const rawBonuses = itemData.raw_data?.bonuses || [];
                itemData.bonuses = this.calculateBonusesForLevel(rawBonuses, 0);
            }
        }
        this.updateAllDescriptions();
        this.updateUI();
        this.updateDustDisplay();
    },

    /**
     * Set the upgrade level of an equipped item
     * @param {string} slotId - Slot identifier (e.g., 'weapon', 'ring-1')
     * @param {number} newLevel - New upgrade level (1-based)
     */
    setItemLevel(slotId, newLevel) {
        const itemData = heroBuild.equipment.slots[slotId];
        if (!itemData) return;

        // Clamp level between 1 and max_level
        const maxLevel = itemData.max_level || 1;
        const clampedLevel = Math.max(1, Math.min(newLevel, maxLevel));

        // Update the level
        itemData.level = clampedLevel;

        // Recalculate bonuses based on new level
        // Note: level is 1-based, but calculation uses 0-based (level - 1)
        const rawBonuses = itemData.raw_data?.bonuses || [];
        itemData.bonuses = this.calculateBonusesForLevel(rawBonuses, clampedLevel - 1);

        // Update all descriptions (hero stats and item levels may affect them)
        this.updateAllDescriptions();

        // Update UI to reflect changes
        this.updateUI();
        this.updateDustDisplay();
    },

    init() {
        // Setup click handlers for all equipment slots
        const equipSlots = document.querySelectorAll('.equip-slot[data-slot-type]');
        equipSlots.forEach(slot => {
            const slotId = slot.id.replace('slot-', '');
            const slotType = slot.dataset.slotType;

            slot.onclick = () => {
                ItemSelectionModal.open(slotId, slotType);
            };
        });

        // Initial UI update to show any pre-equipped items
        this.updateUI();
        this.updateDustDisplay();
    },

    equipItem(slotId, itemData) {
        // Initialize level (defaults to 1 if not provided)
        const initialLevel = itemData.level || 1;

        // Get bonuses from raw_data (API format) or bonuses_raw (legacy)
        const rawBonuses = itemData.raw_data?.bonuses || itemData.bonuses_raw || itemData.bonuses || [];

        // Calculate initial bonuses based on level
        const calculatedBonuses = this.calculateBonusesForLevel(
            rawBonuses,
            initialLevel - 1  // Convert 1-based to 0-based
        );

        // Update heroBuild state
        heroBuild.equipment.slots[slotId] = {
            id: itemData.id,
            name: itemData.name,
            icon: itemData.icon,
            slot: itemData.slot,
            rarity: itemData.rarity,
            bonuses: calculatedBonuses,
            item_set: itemData.item_set,
            max_level: itemData.max_level || 1,
            cost_base: itemData.cost_base || 0,
            cost_per_level: itemData.cost_per_level || 0,
            description: itemData.description,
            description_template: itemData.description_template,
            description_values: itemData.description_values,
            description_args: itemData.description_args || [],
            upgrade_description: itemData.upgrade_description || '',
            upgrade_description_template: itemData.upgrade_description_template || '',
            upgrade_description_args: itemData.upgrade_description_args || [],
            narrative_description: itemData.narrative_description || '',
            raw_data: itemData.raw_data,
            level: initialLevel
        };

        // Update all descriptions (hero stats may have changed)
        this.updateAllDescriptions();

        // Update UI
        this.updateUI();
        this.updateDustDisplay();
    },

    unequipItem(slotId) {
        // Remove from heroBuild state
        heroBuild.equipment.slots[slotId] = null;

        // Update all descriptions (hero stats may have changed)
        this.updateAllDescriptions();

        // Update UI
        this.updateUI();
        this.updateDustDisplay();
    },

    updateUI() {
        // Update all equipment slots to show equipped items or empty state
        for (const [slotId, itemData] of Object.entries(heroBuild.equipment.slots)) {
            const slotElement = document.getElementById(`slot-${slotId}`);
            if (!slotElement) continue;

            if (itemData) {
                // Show equipped item with tooltip
                const rarityColor = ItemSelectionModal.rarityColors[itemData.rarity] || '#ffffff';

                // Get current level and max level
                const currentLevel = itemData.level || 1;
                const maxLevel = itemData.max_level || 1;

                // Always calculate description dynamically using formatItemDescription
                const descriptionText = this.formatItemDescription(itemData, currentLevel) ||
                                       (itemData.bonuses || []).join(', ') ||
                                       'No description';
                const bonusesHTML = `<div class="bonus-line">${descriptionText}</div>`;

                // Calculate dust costs
                const canLevelUp = currentLevel < maxLevel;
                const canLevelDown = currentLevel > 1;
                const upgradeCost = canLevelUp ? this.calculateDustCost(itemData, currentLevel + 1) - this.calculateDustCost(itemData, currentLevel) : 0;
                const downgradeSavings = canLevelDown ? this.calculateDustCost(itemData, currentLevel) - this.calculateDustCost(itemData, currentLevel - 1) : 0;

                const upgradeControlsHTML = `
                    <div class="tooltip-level">Level ${currentLevel}/${maxLevel}</div>
                    <div class="tooltip-upgrade-row">
                        <button class="tooltip-upgrade-btn ${!canLevelUp ? 'disabled' : ''}"
                                onclick="event.stopPropagation(); if (${canLevelUp}) EquipmentManager.setItemLevel('${slotId}', ${currentLevel + 1});">
                            ⏫ ${upgradeCost} <img src="/media/gamedata/resources/dust.png" class="dust-icon-small" alt="dust">
                        </button>
                        <button class="tooltip-upgrade-btn ${!canLevelDown ? 'disabled' : ''}"
                                onclick="event.stopPropagation(); if (${canLevelDown}) EquipmentManager.setItemLevel('${slotId}', ${currentLevel - 1});">
                            ⏬ ${downgradeSavings} <img src="/media/gamedata/resources/dust.png" class="dust-icon-small" alt="dust">
                        </button>
                    </div>
                    <button class="tooltip-remove-btn" onclick="event.stopPropagation(); EquipmentManager.unequipItem('${slotId}');">
                        Remove Item
                    </button>
                `;

                // Add narrative description (flavor text) if available
                const narrativeHTML = itemData.narrative_description
                    ? `<div class="tooltip-narrative">${itemData.narrative_description}</div>`
                    : '';

                // Generate set bonus section if item belongs to a set
                let setHTML = '';
                if (itemData.item_set) {
                    const setData = ItemSetManager.getSetForItem(itemData.id);
                    if (setData) {
                        const equippedCount = ItemSetManager.getEquippedSetItemCount(itemData.item_set);
                        const totalItems = setData.items.length;

                        // Build bonus list with active/inactive styling
                        const bonusListHTML = setData.bonuses.map(bonus => {
                            const isActive = equippedCount >= bonus.requiredItemsAmount;
                            const description = ItemSetManager.formatBonusDescription(setData, bonus);
                            const activeClass = isActive ? 'set-bonus-active' : 'set-bonus-inactive';
                            return `
                                <div class="set-bonus-item ${activeClass}">
                                    <span class="set-bonus-req">(${bonus.requiredItemsAmount})</span>
                                    <span class="set-bonus-desc">${description}</span>
                                </div>
                            `;
                        }).join('');

                        setHTML = `
                            <div class="tooltip-set-section">
                                <div class="set-header">
                                    <span class="set-name">${setData.name}</span>
                                    <span class="set-progress">(${equippedCount}/${totalItems})</span>
                                </div>
                                <div class="set-bonus-list">
                                    ${bonusListHTML}
                                </div>
                            </div>
                        `;
                    }
                }

                slotElement.innerHTML = `
                    <img src="/media/gamedata/items/${itemData.icon}.png"
                         alt="${itemData.name}"
                         style="opacity: 1; width: 90%; height: 90%;">
                    <div class="item-tooltip">
                        <div class="tooltip-header">
                            <span class="item-name" style="color: ${rarityColor}">${itemData.name}</span>
                            <span class="item-rarity">${itemData.rarity}</span>
                        </div>
                        <div class="tooltip-bonuses">
                            ${bonusesHTML}
                        </div>
                        ${narrativeHTML}
                        ${setHTML}
                        ${upgradeControlsHTML}
                    </div>
                `;
                slotElement.style.borderColor = rarityColor;

                // Add/remove upgrade glow class based on level
                if (currentLevel > 1) {
                    slotElement.classList.add('item-upgraded');
                } else {
                    slotElement.classList.remove('item-upgraded');
                }
            } else {
                // Show empty slot with default icon
                const slotType = slotElement.dataset.slotType;
                const defaultIcons = {
                    'unique': 'slot_unique.png',
                    'head': 'slot_head.png',
                    'back': 'slot_cloak.png',
                    'armor': 'slot_armor.png',
                    'weapon': 'slot_left_hand.png',
                    'shield': 'slot_right_hand.png',
                    'belt': 'slot_belt.png',
                    'boots': 'slot_boots.png',
                    'ring': 'slot_ring.png',
                    'accessory': 'slot_item.png'
                };

                const defaultIcon = defaultIcons[slotType] || 'slot_item.png';

                slotElement.innerHTML = `
                    <img src="/media/gamedata/ui/${defaultIcon}" alt="${slotType}">
                `;
                slotElement.style.borderColor = '#3a4555';
                slotElement.classList.remove('item-upgraded');
            }
        }
    }
};

const ItemSetManager = {
    // Cached item sets data from API
    itemSets: [],  // Array of {id, name, items, bonuses, raw_data}
    itemToSetMap: {},  // Map of item_id -> set data for quick lookup

    async init() {
        try {
            const response = await fetch('/api/item-sets/');
            const data = await response.json();
            this.itemSets = data.item_sets || [];

            // Build item -> set lookup map
            this.itemToSetMap = {};
            for (const set of this.itemSets) {
                for (const itemId of set.items) {
                    this.itemToSetMap[itemId] = set;
                }
            }

            console.log(`[ItemSetManager] Loaded ${this.itemSets.length} item sets`);
        } catch (error) {
            console.error('[ItemSetManager] Failed to load item sets:', error);
        }
    },

    /**
     * Get the set that an item belongs to, if any.
     * @param {string} itemId - The item's id_key
     * @returns {object|null} Set data or null
     */
    getSetForItem(itemId) {
        return this.itemToSetMap[itemId] || null;
    },

    /**
     * Count unique equipped items from a specific set.
     * Two copies of the same item count as 1.
     * @param {string} setId - The set's id_key
     * @returns {number} Number of unique items equipped from this set
     */
    getEquippedSetItemCount(setId) {
        const equippedItemIds = new Set();
        for (const slotData of Object.values(heroBuild.equipment.slots)) {
            if (slotData && slotData.item_set === setId) {
                equippedItemIds.add(slotData.id);  // Set ensures uniqueness
            }
        }
        return equippedItemIds.size;
    },

    /**
     * Get all items from a set and their equipped status.
     * @param {string} setId - The set's id_key
     * @returns {Array} Array of {itemId, equipped: boolean}
     */
    getSetItemsStatus(setId) {
        const set = this.itemSets.find(s => s.id === setId);
        if (!set) return [];

        const equippedIds = new Set();
        for (const slotData of Object.values(heroBuild.equipment.slots)) {
            if (slotData && slotData.item_set === setId) {
                equippedIds.add(slotData.id);
            }
        }

        return set.items.map(itemId => ({
            itemId,
            equipped: equippedIds.has(itemId)
        }));
    },

    /**
     * Format a set bonus description using the transpiler system.
     * @param {object} setData - The full set data object
     * @param {object} bonus - The specific bonus object
     * @returns {string} Formatted description
     */
    formatBonusDescription(setData, bonus) {
        if (!bonus.description_template) return '';

        // Create context for CurrentItemSet
        const ctx = {
            currentItemSet: {
                id: setData.id,
                config: setData.raw_data
            },
            currentHero: {
                heroStat: EquipmentManager.getEffectiveHeroStats()
            }
        };

        try {
            return DescriptionRuntime.formatDescription(
                bonus.description_template,
                bonus.description_args || [],
                ctx
            );
        } catch (e) {
            console.error('[ItemSetManager] Error formatting bonus:', e);
            return bonus.description_template;
        }
    },

    /**
     * Get active set bonuses (those with enough items equipped).
     * @param {string} setId - The set's id_key
     * @returns {Array} Array of active bonus objects
     */
    getActiveSetBonuses(setId) {
        const set = this.itemSets.find(s => s.id === setId);
        if (!set) return [];

        const equippedCount = this.getEquippedSetItemCount(setId);
        return set.bonuses.filter(bonus => equippedCount >= bonus.requiredItemsAmount);
    },

    /**
     * Calculate total hero stat bonuses from all active set bonuses.
     * @returns {object} Map of stat_name -> total bonus value
     */
    getActiveSetStatBonuses() {
        const bonuses = {};

        for (const set of this.itemSets) {
            const equippedCount = this.getEquippedSetItemCount(set.id);
            if (equippedCount === 0) continue;

            for (const bonus of set.bonuses) {
                if (equippedCount < bonus.requiredItemsAmount) continue;

                // Process hero bonuses
                for (const heroBonus of (bonus.heroBonuses || [])) {
                    if (heroBonus.type === 'heroStat') {
                        const [statName, value] = heroBonus.parameters;
                        const numValue = parseFloat(value) || 0;
                        bonuses[statName] = (bonuses[statName] || 0) + numValue;
                    }
                }
            }
        }

        return bonuses;
    }
};

const SpellBookManager = {
    // State
    availableSpells: [],
    schools: [],
    equippedSpells: new Array(5).fill(null), // 5 initial slots
    currentSlotIndex: null,
    currentSchoolFilter: 'all',  // Filter for picker modal (school)
    currentModalTypeFilter: 'all',  // Filter for picker modal (combat/global)
    currentBookFilter: null,  // Filter for the spell book view (school) - null means all
    currentTypeFilter: null,  // Filter for the spell book view (combat/global) - null means all
    showEquippedInPicker: false,  // Toggle for showing equipped spells in picker modal
    isAddingNewSlot: false,

    // Initialize - fetch spells from API
    async init() {
        try {
            const response = await fetch('/api/spells/available/');
            const data = await response.json();
            this.availableSpells = data.spells || [];
            this.schools = data.schools || [];
            console.log(`[SpellBookManager] Loaded ${this.availableSpells.length} spells`);
        } catch (error) {
            console.error('[SpellBookManager] Failed to load spells:', error);
        }

        // Load starting spells from hero card data attribute
        this.loadStartingSpells();

        this.renderSchoolTabs();
        this.rebuildSpellGrid();  // Build the initial grid with just the "+" button
    },

    // Load starting spells from hero card data attribute
    loadStartingSpells() {
        const heroCard = document.querySelector('[data-hero-starting-spells]');
        if (!heroCard) return;

        try {
            const startingSpells = JSON.parse(heroCard.dataset.heroStartingSpells || '[]');
            if (!startingSpells.length) return;

            console.log(`[SpellBookManager] Loading ${startingSpells.length} starting spells`);

            // Clear the initial empty slots
            this.equippedSpells = [];

            // Add each starting spell
            startingSpells.forEach(spellData => {
                // The spellData from the template already has all the info we need
                // It matches the structure from api_available_spells
                this.equippedSpells.push({
                    spell: spellData,
                    upgradeLevel: spellData.upgrade_level || 1,
                    isStartingSpell: true  // Mark as starting spell - cannot be removed
                });
                console.log(`[SpellBookManager] Added starting spell: ${spellData.name} (${spellData.id})`);
            });
        } catch (error) {
            console.error('[SpellBookManager] Error loading starting spells:', error);
        }
    },

    // Render school tabs for filtering the spell book (no "All" - toggle to deselect)
    renderSchoolTabs() {
        const container = document.getElementById('spell-school-tabs');
        if (!container) return;

        container.innerHTML = this.schools.map(school => `
            <button class="spell-school-tab" data-school="${school.id}" onclick="SpellBookManager.toggleBookSchoolFilter('${school.id}')">
                ${school.name.replace(' Magic', '')}
            </button>
        `).join('');
    },

    // Toggle the spell book school filter (clicking active one turns it off)
    toggleBookSchoolFilter(schoolId) {
        // Toggle: if already active, clear filter; otherwise set it
        this.currentBookFilter = (this.currentBookFilter === schoolId) ? null : schoolId;

        // Update active tab
        document.querySelectorAll('#spell-school-tabs .spell-school-tab').forEach(tab => {
            tab.classList.toggle('active', tab.dataset.school === this.currentBookFilter);
        });

        // Apply all filters
        this.applyAllFilters();
    },

    // Toggle the spell book type filter (clicking active one turns it off)
    toggleBookTypeFilter(type) {
        // Toggle: if already active, clear filter; otherwise set it
        this.currentTypeFilter = (this.currentTypeFilter === type) ? null : type;

        // Update active button
        document.querySelectorAll('.spell-type-filters .spell-type-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.type === this.currentTypeFilter);
        });

        // Apply all filters
        this.applyAllFilters();
    },

    // Apply both school and type filters (null means show all)
    applyAllFilters() {
        document.querySelectorAll('.spell-slot').forEach((slot, index) => {
            const equipped = this.equippedSpells[index];

            if (!equipped || !equipped.spell) {
                // Empty slots (+ button): always show
                slot.classList.remove('filtered-out');
            } else {
                // Check school filter (null means all)
                const matchesSchool = this.currentBookFilter === null ||
                                      equipped.spell.school === this.currentBookFilter;

                // Check type filter (null means all)
                const matchesType = this.currentTypeFilter === null ||
                                   equipped.spell.spell_type === this.currentTypeFilter;

                // Must match BOTH filters
                slot.classList.toggle('filtered-out', !(matchesSchool && matchesType));
            }
        });
    },

    // Open the spell picker modal
    openSpellPicker(slotIndex) {
        this.isAddingNewSlot = false; // We're replacing/filling an existing slot
        this.currentSlotIndex = slotIndex;
        this.renderSpellPicker();
    },

    // Add new spell slot
    addNewSpell() {
        this.isAddingNewSlot = true;
        this.currentSlotIndex = this.equippedSpells.length; // Next available index
        this.renderSpellPicker();
    },

    // Render the modal with spell list
    renderSpellPicker() {
        const container = document.getElementById('skill-modal-container');

        // Sync modal filters from spell book filters (convert null to 'all' for modal)
        this.currentSchoolFilter = this.currentBookFilter || 'all';
        this.currentModalTypeFilter = this.currentTypeFilter || 'all';

        container.innerHTML = `
            <div class="modal-overlay" onclick="SpellBookManager.closeSpellPicker()">
                <div class="skill-modal" onclick="event.stopPropagation()">
                    <div class="modal-header">
                        <h2>Select Spell</h2>
                        <div class="modal-controls">
                            <input type="text"
                                   id="spell-search-input"
                                   class="skill-search"
                                   placeholder="Search spells..."
                                   oninput="SpellBookManager.filterSpells(this.value)">
                            <label class="scroll-toggle">
                                <input type="checkbox"
                                       id="show-equipped-toggle"
                                       ${this.showEquippedInPicker ? 'checked' : ''}
                                       onchange="SpellBookManager.toggleShowEquipped(this.checked)">
                                Show in book
                            </label>
                        </div>
                    </div>
                    <div class="spell-school-tabs-modal">
                        <button class="spell-school-tab-modal ${this.currentSchoolFilter === 'all' ? 'active' : ''}" data-school="all" onclick="SpellBookManager.filterBySchool('all')">All</button>
                        ${this.schools.map(school => `
                            <button class="spell-school-tab-modal ${this.currentSchoolFilter === school.id ? 'active' : ''}" data-school="${school.id}" onclick="SpellBookManager.filterBySchool('${school.id}')">
                                ${school.name.replace(' Magic', '')}
                            </button>
                        `).join('')}
                    </div>
                    <div class="spell-type-tabs-modal">
                        <button class="spell-type-tab-modal ${this.currentModalTypeFilter === 'all' ? 'active' : ''}" data-type="all" onclick="SpellBookManager.filterModalByType('all')">All</button>
                        <button class="spell-type-tab-modal ${this.currentModalTypeFilter === 'combat' ? 'active' : ''}" data-type="combat" onclick="SpellBookManager.filterModalByType('combat')">Combat</button>
                        <button class="spell-type-tab-modal ${this.currentModalTypeFilter === 'global' ? 'active' : ''}" data-type="global" onclick="SpellBookManager.filterModalByType('global')">Global Map</button>
                    </div>
                    <div class="skill-list" id="spell-picker-list">
                        ${this.renderSpellList(this.getFilteredSpells())}
                    </div>
                </div>
            </div>
        `;
    },

    // Check if a spell is already equipped
    isSpellEquipped(spellId) {
        return this.equippedSpells.some(eq => eq && eq.spell && eq.spell.id === spellId);
    },

    // Render the list of spells
    renderSpellList(spells) {
        if (spells.length === 0) {
            return '<div class="no-results">No spells found</div>';
        }

        return spells.map(spell => {
            const isEquipped = this.isSpellEquipped(spell.id);
            const description = this.formatSpellDescription(spell, 1);
            const clickHandler = isEquipped ? '' : `onclick="SpellBookManager.selectSpell('${spell.id}')"`;
            const disabledClass = isEquipped ? ' spell-option-disabled' : '';

            return `
                <div class="skill-option spell-option${disabledClass}" ${clickHandler}>
                    <div class="skill-icon-wrapper spell-icon-round">
                        <img src="/media/gamedata/spells/${spell.icon || spell.id}.png"
                             class="skill-icon"
                             alt="${spell.id}"
                             onerror="SpellBookManager.handleSpellIconError(this, '${spell.icon || spell.id}')">
                        ${isEquipped ? '<div class="spell-equipped-badge">In Book</div>' : ''}
                    </div>
                    <div class="skill-info">
                        <div class="skill-name">${this.formatSpellName(spell.id_key || spell.id)}</div>
                        <div class="skill-meta" style="color: #7ec8e3; font-size: 0.8rem; margin-bottom: 6px;">
                            ${spell.school_display} • Tier ${spell.level} • ${spell.spell_type === 'global' ? 'Global Map' : 'Combat'}
                        </div>
                        <div class="skill-desc spell-description">${description}</div>
                    </div>
                </div>
            `;
        }).join('');
    },

    // Filter by search text
    filterSpells(searchText) {
        document.getElementById('spell-picker-list').innerHTML = this.renderSpellList(this.getFilteredSpells(searchText));
    },

    // Filter by school tab
    filterBySchool(schoolId) {
        this.currentSchoolFilter = schoolId;

        // Update active tab
        document.querySelectorAll('.spell-school-tab-modal').forEach(tab => {
            tab.classList.toggle('active', tab.dataset.school === schoolId);
        });

        // Clear search input when changing school
        const searchInput = document.getElementById('spell-search-input');
        if (searchInput) searchInput.value = '';

        document.getElementById('spell-picker-list').innerHTML = this.renderSpellList(this.getFilteredSpells());
    },

    // Filter by type tab (Combat/Global Map)
    filterModalByType(type) {
        this.currentModalTypeFilter = type;

        // Update active tab
        document.querySelectorAll('.spell-type-tab-modal').forEach(tab => {
            tab.classList.toggle('active', tab.dataset.type === type);
        });

        // Clear search input when changing type
        const searchInput = document.getElementById('spell-search-input');
        if (searchInput) searchInput.value = '';

        document.getElementById('spell-picker-list').innerHTML = this.renderSpellList(this.getFilteredSpells());
    },

    // Get spells filtered by current school, type, and equipped toggle
    getFilteredSpells(searchText = '') {
        let spells = this.availableSpells;

        // Filter by school
        if (this.currentSchoolFilter !== 'all') {
            spells = spells.filter(s => s.school === this.currentSchoolFilter);
        }

        // Filter by type (combat/global)
        if (this.currentModalTypeFilter !== 'all') {
            spells = spells.filter(s => s.spell_type === this.currentModalTypeFilter);
        }

        // Filter by search text
        if (searchText) {
            const search = searchText.toLowerCase();
            spells = spells.filter(spell => {
                const formattedName = this.formatSpellName(spell.id_key || spell.id).toLowerCase();
                return formattedName.includes(search) ||
                       spell.id.toLowerCase().includes(search) ||
                       spell.school_display.toLowerCase().includes(search);
            });
        }

        // Filter out equipped spells if toggle is off
        if (!this.showEquippedInPicker) {
            spells = spells.filter(spell => !this.isSpellEquipped(spell.id));
        }

        return spells;
    },

    // Toggle showing equipped spells in picker
    toggleShowEquipped(checked) {
        this.showEquippedInPicker = checked;
        const searchText = document.getElementById('spell-search-input')?.value || '';
        document.getElementById('spell-picker-list').innerHTML = this.renderSpellList(this.getFilteredSpells(searchText));
    },

    // Select a spell and assign it to the slot
    selectSpell(spellId) {
        const spell = this.availableSpells.find(s => s.id === spellId);
        if (!spell) {
            console.error('[SpellBookManager] Spell not found:', spellId);
            return;
        }

        if (this.isAddingNewSlot) {
            // Create a new slot with the spell
            this.equippedSpells.push({
                spell: spell,
                upgradeLevel: 1
            });
            // Create new slot element in the DOM
            this.createNewSlotElement(this.equippedSpells.length - 1);
        } else {
            // Fill existing empty slot
            this.equippedSpells[this.currentSlotIndex] = {
                spell: spell,
                upgradeLevel: 1  // Start at level 1
            };
            this.updateSlot(this.currentSlotIndex);
        }

        console.log(`[SpellBookManager] Equipped ${spell.id}, total slots: ${this.equippedSpells.length}`);

        this.isAddingNewSlot = false;
        this.closeSpellPicker();
    },

    // Helper to format spell name from id_key
    formatSpellName(idKey) {
        // Convert "day_01_magic_blessing" to "Blessing"
        // Remove school prefix and number, capitalize
        const parts = idKey.split('_');
        // Find the meaningful part (usually after "magic")
        const magicIndex = parts.indexOf('magic');
        if (magicIndex >= 0 && magicIndex < parts.length - 1) {
            return parts.slice(magicIndex + 1).map(word =>
                word.charAt(0).toUpperCase() + word.slice(1)
            ).join(' ');
        }
        // Fallback: just capitalize all parts
        return parts.map(word =>
            word.charAt(0).toUpperCase() + word.slice(1)
        ).join(' ');
    },

    // Get fallback icon path for _special variants
    getFallbackIconPath(spellId) {
        // Strip _special suffix to get base spell icon
        if (spellId.endsWith('_special')) {
            return `/media/gamedata/spells/${spellId.replace(/_special$/, '')}.png`;
        }
        // For other cases, try a generic fallback
        return '/media/gamedata/ui/magic_icon.png';
    },

    // Handle spell icon load error - try fallback
    handleSpellIconError(img, spellId) {
        const fallbackPath = this.getFallbackIconPath(spellId);
        if (img.src !== fallbackPath && !img.dataset.triedFallback) {
            img.dataset.triedFallback = 'true';
            img.src = fallbackPath;
        }
    },

    // Format spell description using the description pipeline
    formatSpellDescription(spell, upgradeLevel = 1) {
        // Check if description runtime is available
        if (typeof DescriptionRuntime === 'undefined' || typeof DescriptionFunctions === 'undefined') {
            console.warn('[SpellBookManager] Description runtime not available');
            return spell.description_template || 'No description available';
        }

        try {
            // Get effective hero stats
            const effectiveStats = EquipmentManager ? EquipmentManager.getEffectiveHeroStats() : {};

            // Create context for the spell using the same structure as HeroState
            // The transpiled functions expect data like targetMechanics to be directly on currentMagic
            // Use the magicDealer for the current upgrade level (0-indexed)
            const magicDealers = spell.raw_data?.battleMagic?.magicDealers || [];
            const dealerIndex = Math.min(upgradeLevel - 1, magicDealers.length - 1);
            const magicDealer = magicDealers[Math.max(0, dealerIndex)] || {};
            const ctx = {
                currentMagic: {
                    id: spell.id_key || spell.id,
                    upgradeLevel: upgradeLevel - 1,  // 0-indexed
                    level: spell.level,
                    school: spell.school,
                    // Spread magicDealer data so targetMechanics is directly accessible
                    ...magicDealer,
                    // Also include the full raw_data for functions that need config
                    config: spell.raw_data || {},
                },
                currentHero: {
                    stats: effectiveStats,
                    getSpellPower: (school) => {
                        // Base spell power + school-specific bonuses
                        return effectiveStats.spellPower || 0;
                    }
                }
            };

            // Select the correct description template/args for this upgrade level
            // spell.descriptions is an array where index 0 = level 1, index 1 = level 2, etc.
            const descriptions = spell.descriptions || [];
            const descIndex = Math.min(upgradeLevel - 1, descriptions.length - 1);
            const levelDesc = descriptions[Math.max(0, descIndex)] || {};

            // Use level-specific template/args, falling back to legacy fields
            const template = levelDesc.description_template || spell.description_template || '';
            const args = levelDesc.description_args || spell.description_args || [];

            if (!template) {
                return 'No description available';
            }

            return DescriptionRuntime.formatDescription(template, args, ctx);
        } catch (error) {
            console.warn('[SpellBookManager] Error formatting spell description:', error);
            return spell.description_template || 'Error loading description';
        }
    },

    // Create a new slot element in the DOM
    createNewSlotElement(index) {
        const grid = document.getElementById('spell-grid');
        const equipped = this.equippedSpells[index];
        const spell = equipped.spell;
        const description = this.formatSpellDescription(spell, equipped.upgradeLevel);
        const maxLevel = spell.max_upgrade_level || 3;
        const currentLevel = equipped.upgradeLevel;

        const slotDiv = document.createElement('div');
        slotDiv.className = 'spell-slot equipped';
        slotDiv.dataset.slotIndex = index;
        const isStarting = equipped.isStartingSpell;
        slotDiv.innerHTML = `
            <img src="/media/gamedata/spells/${spell.icon || spell.id_key || spell.id}.png"
                 alt="${spell.id_key || spell.id}"
                 class="spell-icon"
                 onerror="SpellBookManager.handleSpellIconError(this, '${spell.icon || spell.id_key || spell.id}')">
            <button class="spell-slot-remove" onclick="event.stopPropagation(); SpellBookManager.removeSpell(${index})" ${isStarting ? 'disabled' : ''}>×</button>
            ${isStarting ? '<div class="spell-starting-badge">Starting</div>' : ''}
            <div class="spell-tooltip">
                <div class="spell-tooltip-name">${spell.name || this.formatSpellName(spell.id_key || spell.id)}</div>
                <div class="spell-tooltip-school">${spell.school_display}</div>
                <div class="spell-tooltip-type">${spell.spell_type === 'global' ? 'Global Map' : 'Combat'} Spell</div>
                <div class="spell-tooltip-tier">Tier ${spell.level}</div>
                <div class="spell-tooltip-level">Level ${currentLevel}/${maxLevel}</div>
                <div class="spell-tooltip-desc">${description}</div>
                <div class="spell-tooltip-actions">
                    <button class="spell-action-btn"
                            onclick="event.stopPropagation(); SpellBookManager.upgradeSpell(${index})"
                            ${currentLevel >= maxLevel ? 'disabled' : ''}>
                        Upgrade
                    </button>
                    <button class="spell-action-btn"
                            onclick="event.stopPropagation(); SpellBookManager.downgradeSpell(${index})"
                            ${currentLevel <= 1 ? 'disabled' : ''}>
                        Downgrade
                    </button>
                    <button class="spell-action-btn spell-remove-btn"
                            onclick="event.stopPropagation(); SpellBookManager.removeSpell(${index})"
                            ${isStarting ? 'disabled' : ''}>
                        Remove
                    </button>
                </div>
            </div>
        `;

        // Add click handler for spell replacement
        slotDiv.addEventListener('click', () => this.openSpellPicker(index));

        // Insert before the "+" add button (which should always be last)
        const addButton = grid.querySelector('.spell-slot-add');
        if (addButton) {
            grid.insertBefore(slotDiv, addButton);
        } else {
            grid.appendChild(slotDiv);
        }
    },

    // Update a single slot's UI to show equipped spell or empty state
    updateSlot(index) {
        const slotElement = document.querySelector(`.spell-slot[data-slot-index="${index}"]`);
        if (!slotElement) return;

        const equipped = this.equippedSpells[index];

        if (equipped === null) {
            // Empty slot
            slotElement.innerHTML = '<span class="add-text">+</span>';
            slotElement.classList.remove('equipped');
        } else {
            // Filled slot with spell
            const spell = equipped.spell;
            const description = this.formatSpellDescription(spell, equipped.upgradeLevel);
            const maxLevel = spell.max_upgrade_level || 3;
            const currentLevel = equipped.upgradeLevel;
            const isStarting = equipped.isStartingSpell;

            slotElement.innerHTML = `
                <img src="/media/gamedata/spells/${spell.icon || spell.id_key || spell.id}.png"
                     alt="${spell.id_key || spell.id}"
                     class="spell-icon"
                     onerror="SpellBookManager.handleSpellIconError(this, '${spell.icon || spell.id_key || spell.id}')">
                <button class="spell-slot-remove" onclick="event.stopPropagation(); SpellBookManager.removeSpell(${index})" ${isStarting ? 'disabled' : ''}>×</button>
                ${isStarting ? '<div class="spell-starting-badge">Starting</div>' : ''}
                <div class="spell-tooltip">
                    <div class="spell-tooltip-name">${spell.name || this.formatSpellName(spell.id_key || spell.id)}</div>
                    <div class="spell-tooltip-school">${spell.school_display}</div>
                    <div class="spell-tooltip-type">${spell.spell_type === 'global' ? 'Global Map' : 'Combat'} Spell</div>
                    <div class="spell-tooltip-tier">Tier ${spell.level}</div>
                    <div class="spell-tooltip-level">Level ${currentLevel}/${maxLevel}</div>
                    <div class="spell-tooltip-desc">${description}</div>
                    <div class="spell-tooltip-actions">
                        <button class="spell-action-btn"
                                onclick="event.stopPropagation(); SpellBookManager.upgradeSpell(${index})"
                                ${currentLevel >= maxLevel ? 'disabled' : ''}>
                            Upgrade
                        </button>
                        <button class="spell-action-btn"
                                onclick="event.stopPropagation(); SpellBookManager.downgradeSpell(${index})"
                                ${currentLevel <= 1 ? 'disabled' : ''}>
                            Downgrade
                        </button>
                        <button class="spell-action-btn spell-remove-btn"
                                onclick="event.stopPropagation(); SpellBookManager.removeSpell(${index})"
                                ${isStarting ? 'disabled' : ''}>
                            Remove
                        </button>
                    </div>
                </div>
            `;
            slotElement.classList.add('equipped');
        }

        // Reapply all filters
        this.applyAllFilters();
    },

    // Upgrade spell to next level
    upgradeSpell(index) {
        const equipped = this.equippedSpells[index];
        if (!equipped) return;

        const maxLevel = equipped.spell.max_upgrade_level || 3;
        if (equipped.upgradeLevel >= maxLevel) return;

        equipped.upgradeLevel++;
        console.log(`[SpellBookManager] Upgraded spell to level ${equipped.upgradeLevel}`);

        this.updateSlot(index);
    },

    // Downgrade spell to previous level
    downgradeSpell(index) {
        const equipped = this.equippedSpells[index];
        if (!equipped) return;

        if (equipped.upgradeLevel <= 1) return;

        equipped.upgradeLevel--;
        console.log(`[SpellBookManager] Downgraded spell to level ${equipped.upgradeLevel}`);

        this.updateSlot(index);
    },

    // Remove spell from slot
    removeSpell(index) {
        const equipped = this.equippedSpells[index];
        if (!equipped) return;

        // Cannot remove starting spells
        if (equipped.isStartingSpell) {
            console.log(`[SpellBookManager] Cannot remove starting spell`);
            return;
        }

        const spellName = this.formatSpellName(equipped.spell.id_key || equipped.spell.id);
        console.log(`[SpellBookManager] Removing spell ${spellName} from slot ${index}`);

        // Remove the spell and shift remaining spells up
        this.equippedSpells.splice(index, 1);
        this.rebuildSpellGrid();
    },

    // Max all equipped spells
    maxAllSpells() {
        let upgraded = 0;
        this.equippedSpells.forEach((equipped, index) => {
            if (equipped !== null) {
                const maxLevel = equipped.spell.max_upgrade_level || 3;
                if (equipped.upgradeLevel < maxLevel) {
                    equipped.upgradeLevel = maxLevel;
                    upgraded++;
                }
            }
        });

        if (upgraded > 0) {
            console.log(`[SpellBookManager] Maxed ${upgraded} spells`);
            this.rebuildSpellGrid();
        }
    },

    // Reset all equipped spells to level 1
    resetAllSpells() {
        let reset = 0;
        this.equippedSpells.forEach((equipped, index) => {
            if (equipped !== null && equipped.upgradeLevel > 1) {
                equipped.upgradeLevel = 1;
                reset++;
            }
        });

        if (reset > 0) {
            console.log(`[SpellBookManager] Reset ${reset} spells to level 1`);
            this.rebuildSpellGrid();
        }
    },

    // Rebuild the entire grid - shows filled spells + one "+" button to add more
    rebuildSpellGrid() {
        const grid = document.getElementById('spell-grid');
        grid.innerHTML = '';

        // Remove any null entries (clean up the array)
        this.equippedSpells = this.equippedSpells.filter(e => e !== null);

        // Render all equipped spells
        this.equippedSpells.forEach((equipped, index) => {
            const slotDiv = document.createElement('div');
            slotDiv.className = 'spell-slot equipped';
            slotDiv.dataset.slotIndex = index;

            const spell = equipped.spell;
            const description = this.formatSpellDescription(spell, equipped.upgradeLevel);
            const maxLevel = spell.max_upgrade_level || 4;
            const currentLevel = equipped.upgradeLevel;
            const isStarting = equipped.isStartingSpell;

            slotDiv.innerHTML = `
                <img src="/media/gamedata/spells/${spell.icon || spell.id_key || spell.id}.png"
                     alt="${spell.id_key || spell.id}"
                     class="spell-icon"
                     onerror="SpellBookManager.handleSpellIconError(this, '${spell.icon || spell.id_key || spell.id}')">
                <button class="spell-slot-remove" onclick="event.stopPropagation(); SpellBookManager.removeSpell(${index})" ${isStarting ? 'disabled' : ''}>×</button>
                ${isStarting ? '<div class="spell-starting-badge">Starting</div>' : ''}
                <div class="spell-tooltip">
                    <div class="spell-tooltip-name">${spell.name || this.formatSpellName(spell.id_key || spell.id)}</div>
                    <div class="spell-tooltip-school">${spell.school_display}</div>
                    <div class="spell-tooltip-type">${spell.spell_type === 'global' ? 'Global Map' : 'Combat'} Spell</div>
                    <div class="spell-tooltip-tier">Tier ${spell.level}</div>
                    <div class="spell-tooltip-level">Level ${currentLevel}/${maxLevel}</div>
                    <div class="spell-tooltip-desc">${description}</div>
                    <div class="spell-tooltip-actions">
                        <button class="spell-action-btn"
                                onclick="event.stopPropagation(); SpellBookManager.upgradeSpell(${index})"
                                ${currentLevel >= maxLevel ? 'disabled' : ''}>Upgrade</button>
                        <button class="spell-action-btn"
                                onclick="event.stopPropagation(); SpellBookManager.downgradeSpell(${index})"
                                ${currentLevel <= 1 ? 'disabled' : ''}>Downgrade</button>
                        <button class="spell-action-btn spell-remove-btn"
                                onclick="event.stopPropagation(); SpellBookManager.removeSpell(${index})"
                                ${isStarting ? 'disabled' : ''}>Remove</button>
                    </div>
                </div>
            `;

            // Click to replace this spell
            slotDiv.addEventListener('click', () => this.openSpellPicker(index));
            grid.appendChild(slotDiv);
        });

        // Add the "+" button at the end to add new spells
        const addSlot = document.createElement('div');
        addSlot.className = 'spell-slot spell-slot-add';
        addSlot.innerHTML = '<span class="add-text">+</span>';
        addSlot.addEventListener('click', () => this.addNewSpell());
        grid.appendChild(addSlot);

        this.applyAllFilters();
    },

    // Update all spell descriptions (called when hero stats change)
    updateAllDescriptions() {
        console.log('[SpellBookManager] Updating all spell descriptions');

        // Rebuild the grid to recalculate all descriptions
        this.rebuildSpellGrid();
    },

    // Close the modal
    closeSpellPicker() {
        this.currentSlotIndex = null;
        this.isAddingNewSlot = false;
        document.getElementById('skill-modal-container').innerHTML = '';
    }
};

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    SkillManager.init();
    AdvancedClassManager.init();
    ItemSetManager.init();  // Load item sets before equipment
    EquipmentManager.init();
    SpellBookManager.init();

    // Close modal on Escape key
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
            SkillSelectionModal.close();
            SubskillSelectionModal.close();
            ItemSelectionModal.close();
            SpellBookManager.closeSpellPicker();
        }
    });
});
</script>
